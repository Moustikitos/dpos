{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"dposlib package aims to provide a simple API to ARK blockchain and forks. Support this project # Buy \u0466 and: [X] Send \u0466 to AUahWfkfr5J4tYakugRbfow7RWVTK35GPW [X] Vote arky on Ark blockchain and earn \u0466 weekly Quick View # Ubuntu dependencies installation # sudo apt-get install python python-dev python3 python3-dev sudo apt-get install python-setuptools python3-setuptools sudo apt-get install python-pip python3-pip Available network # Ark-core 3.0 ( API + transaction type 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 & 10 ) [X] devnet : dark Ark-core 2.6 ( API + transaction type 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 & 10 ) [X] mainet : ark [X] devnet : dark2 Ark forks ( API + transaction type 0 , 1 , 2 & 3 ) [x] Internet of People [X] mainet : iop [X] devnet : diop [x] Ripa : ripa [x] Phantom : phantom [x] Qredit : qredit Main features # An intuitive REST API # >>> from dposlib import rest >>> rest.use(\"dark\") True >>> # ~/api/delegates/darktoons endpoint >>> rest.GET.api.delegates.darktoons() {'data': {'username': 'darktoons', 'address': 'D7seWn8JLVwX4nHd9hh2Lf7gvZNiRJ7qLk', 'publicKey': '03a02b9d5fdd1307c2ee4652ba54d492d1fd11a7d1bb3f3a44c4a05e79f19de933', 'votes': 9385785081642, 'rank': 45, 'blocks': {'produced': 32015, 'last': {'id': '9d5085e503e09c656152b541bc243155f560347aa8b377d3f2f9a1cb71900d90', 'height': 2544602, 'timestamp': {'epoch': 69406864, 'unix': 1559508064, 'human': '2019-06-02T20:41:04.000Z'}}}, 'production': {'approval': 0.07}, 'forged': {'fees': 14640580130, 'rewards': 6403000000000, 'total': 6417640580130}}} >>> # ~/api/node/fees endpoint >>> rest.GET.api.node.fees() {'meta': {'days': 7}, 'data': [{'type': '0', 'min': '200000', 'max': '10000000', 'avg': '1089596', 'sum': '14887144978', 'median': '460000'}, {'type': '1', 'min': '500000000', 'max': '500000000', 'avg': '500000000', 'sum': '313500000000', 'median': '500000000'}, {'type': '3', 'min': '10000000', 'max': '100000000', 'avg': '58541781', 'sum': '1756253430', 'median': '61114510'}]} >>> rest.use(\"ark\") True >>> delegate0 = rest.GET.api.delegates(returnKey=\"data\")[0] >>> delegate0[\"username\"] u'binance_staking' Fast way to interact with blockchain # >>> import dposlib >>> rest.use(\"dark\") >>> # send 1 token to D7seWn8JLVwX4nHd9hh2Lf7gvZNiRJ7qLk with a simple message >>> tx = dposlib.core.transfer(1, \"D7seWn8JLVwX4nHd9hh2Lf7gvZNiRJ7qLk\", \"message\") >>> # sign tx with secret and [optional second secret] >>> tx.finalize(\"first secret\", \"second secret\") >>> tx { \"amount\": 100000000, \"asset\": {}, \"fee\": 1090241, \"id\": \"1e967879eb134712afd2b2a606be8460468b80aab857fa99a88cf8da0d72bd5d\", \"recipientId\": \"D7seWn8JLVwX4nHd9hh2Lf7gvZNiRJ7qLk\", \"senderId\": \"D7seWn8JLVwX4nHd9hh2Lf7gvZNiRJ7qLk\", \"senderPublicKey\": \"03a02b9d5fdd1307c2ee4652ba54d492d1fd11a7d1bb3f3a44c4a05e79f19de933\", \"signSignature\": \"3045022100a8dd9c50b18002bd6f8ffe9f1c0700cafb95de18670b48fa76afd85c3003a2d202200a1cc102c13857a38d8311a5c80a9222329f0c53f3305c70c91979efd5288d21\", \"signature\": \"304402206576aee7893f3c038d58a6def5180881077531c4b1ebe87e835da2dbe40d0670022064ae37be3f160b0c969459e06912ee619997ccf303e6d919135cdf594a74b77d\", \"timestamp\": 69407340, \"type\": 0, \"vendorField\": \"message\" } >>> # broadcast transaction >>> rest.POST.api.transactions(transactions=[tx]) {'data': {'accept': ['1e967879eb134712afd2b2a606be8460468b80aab857fa99a88cf8da0d72bd5d'], 'broadcast': ['1e967879eb134712afd2b2a606be8460468b80aab857fa99a88cf8da0d72bd5d'], 'excess': [], 'invalid': []}} Network API # >>> import dposlib >>> rest.use(\"ark\") >>> dlgt = dposlib.core.api.Delegate(\"arky\") # get delegate by username >>> dlgt.forged {'fees': 3294.7, 'forged': 227230.7, 'rewards': 223936.0} >>> dlgt.address 'ARfDVWZ7Zwkox3ZXtMQQY1HYSANMB88vWE' >>> blk = dlgt.lastBlock # get last forged block >>> blk { \"blockSignature\": \"304402200a496a628c2741537538f0492f9d683d3c4f1b30c8dd03c33ad8fbe79d08b6eb02206cdec7e1210db53a3ca22da30912479ff3644d3a1ed1d878417d5965f34dfd6d\", \"confirmations\": 68, \"generatorId\": \"ARfDVWZ7Zwkox3ZXtMQQY1HYSANMB88vWE\", \"generatorPublicKey\": \"030da05984d579395ce276c0dd6ca0a60140a3c3d964423a04e7abe110d60a15e9\", \"height\": 5862354, \"id\": \"1894085440657345411\", \"numberOfTransactions\": 0, \"payloadHash\": \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\", \"payloadLength\": 0, \"previousBlock\": \"11181074894913507025\", \"reward\": 2.0, \"timestamp\": 47535768, \"totalAmount\": 0.0, \"totalFee\": 0.0, \"totalForged\": 2.0, \"version\": 0 } >>> blk.transactions() [] >>> wlt = dposlib.core.api.Wallet(dlgt.address) # get wallet by address >>> wlt.balance 2537.42979112 >>> for elem in [(tx[\"recipientId\"], tx[\"amount\"]) for tx in wlt.lastTransactions(2)]: ... print(elem) ... ('AHMXV6UdkVxsTwMqeoeqdpotRRmGZZaAtj', 0.08403461) ('AUahWfkfr5J4tYakugRbfow7RWVTK35GPW', 329.32420472) >>> wlt.link(\"secret passphrase here\") >>> wlt.send(1, \"ARfDVWZ7Zwkox3ZXtMQQY1HYSANMB88vWE\") {'transactionIds': ['bbce72e7a76f5f71209c8ab29b4b4299a409241dfc77835150459a34bd5a5c16'], 'success': True} Version # 0.3.5 current work # [x] ledger.com Ark app support [ ] Ark-core v 3.0.x compliancy [ ] entity and business transactions implementation 0.3.4 # [x] removed requests dependency [x] multisignature api and app run as system services 0.3.3 # [x] offline start fixed [x] api.Wallet fixed [x] added pythonic datetime attribute to Transaction class 0.3.2 # [x] better vendorFieldHex field handling [x] dposlib.blockchain.Transaction behaviour improvement [x] tx versioning defined in net module [x] bridge for ark-core 2.5 and 2.6 0.3.1 # [x] multisignature client-server api 0.3.0 # [x] flake8 compliancy [x] Ark 2.6 compatibility [x] removed package resources dependencies [x] ecdsa lib replaced by builtin secp256k1 [x] added Iop mainnet and devnet [x] Lisk and forks dev stopped [x] ldgr import now optional [x] sphinx doc added 0.2.2 # [x] Ark v2.5 headers fix [x] Ark v2.5 BigInt fix [x] packaging improvement [x] rest returnKey behaviour improvement 0.2.1 # [x] added lisk blockchain [x] added shift , t.shift and qredit network [x] added .cold data in package distribution [x] transaction types 0 , 1 and 3 added to lisk.v09 network [x] python 2.x compliancy for util.data package 0.2.0 # [x] ark.v2 api improvement [x] dposlib.util.misc module improvement [x] upVote/downVote bugfix 0.1.9 # [x] travis-ci integration [x] dposlib.core.Transaction interface improvement [x] Ark v1 and v2 cross-dependency removed [x] offline work feature added 0.1.8 # [x] added ark v2.4 compatibility [x] api wallet link using getpass library [x] added ledger nano S support (transaction type 0, 1, 2 & 3) [x] peer selection now checks syncing status 0.1.7 # [x] added transaction and rest MarkDown documentation files [x] dposlib.core.api is both python 2.x and 3.x compliant [x] added Webhook api (experimental) [x] fee data initialisation improvement [x] transaction broadcasting improvement [x] peer selection improvement [x] Lisk blockchain and forks developpement frozen 0.1.6 # [x] Ark-core v 2.1.x compatibility 0.1.5 # [x] compatibility with both ark-core v2 devnet and mainnet 0.1.4 # [x] Python 2.x compatibility fix [x] dposlib.core.Transaction.sign does not set fees anymore [x] dposlib.core.Transaction.finalize set fees before signature [x] dposlib.core.Transaction fee management improved 0.1.3 # [x] REST requests header bugfix (ubuntu) 0.1.2 # [x] Packaging improvement 0.1.1 # [x] ARK packaging improvement ( v1 and v2 ) [x] LISK packaging improvement ( v09 and v10 ) [x] ARK dynamicFee implementation [x] Network API created 0.1.0 # [x] First rebrand","title":"Home"},{"location":"#support-this-project","text":"Buy \u0466 and: [X] Send \u0466 to AUahWfkfr5J4tYakugRbfow7RWVTK35GPW [X] Vote arky on Ark blockchain and earn \u0466 weekly","title":"Support this project"},{"location":"#quick-view","text":"","title":"Quick View"},{"location":"#ubuntu-dependencies-installation","text":"sudo apt-get install python python-dev python3 python3-dev sudo apt-get install python-setuptools python3-setuptools sudo apt-get install python-pip python3-pip","title":"Ubuntu dependencies installation"},{"location":"#available-network","text":"Ark-core 3.0 ( API + transaction type 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 & 10 ) [X] devnet : dark Ark-core 2.6 ( API + transaction type 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 & 10 ) [X] mainet : ark [X] devnet : dark2 Ark forks ( API + transaction type 0 , 1 , 2 & 3 ) [x] Internet of People [X] mainet : iop [X] devnet : diop [x] Ripa : ripa [x] Phantom : phantom [x] Qredit : qredit","title":"Available network"},{"location":"#main-features","text":"","title":"Main features"},{"location":"#an-intuitive-rest-api","text":">>> from dposlib import rest >>> rest.use(\"dark\") True >>> # ~/api/delegates/darktoons endpoint >>> rest.GET.api.delegates.darktoons() {'data': {'username': 'darktoons', 'address': 'D7seWn8JLVwX4nHd9hh2Lf7gvZNiRJ7qLk', 'publicKey': '03a02b9d5fdd1307c2ee4652ba54d492d1fd11a7d1bb3f3a44c4a05e79f19de933', 'votes': 9385785081642, 'rank': 45, 'blocks': {'produced': 32015, 'last': {'id': '9d5085e503e09c656152b541bc243155f560347aa8b377d3f2f9a1cb71900d90', 'height': 2544602, 'timestamp': {'epoch': 69406864, 'unix': 1559508064, 'human': '2019-06-02T20:41:04.000Z'}}}, 'production': {'approval': 0.07}, 'forged': {'fees': 14640580130, 'rewards': 6403000000000, 'total': 6417640580130}}} >>> # ~/api/node/fees endpoint >>> rest.GET.api.node.fees() {'meta': {'days': 7}, 'data': [{'type': '0', 'min': '200000', 'max': '10000000', 'avg': '1089596', 'sum': '14887144978', 'median': '460000'}, {'type': '1', 'min': '500000000', 'max': '500000000', 'avg': '500000000', 'sum': '313500000000', 'median': '500000000'}, {'type': '3', 'min': '10000000', 'max': '100000000', 'avg': '58541781', 'sum': '1756253430', 'median': '61114510'}]} >>> rest.use(\"ark\") True >>> delegate0 = rest.GET.api.delegates(returnKey=\"data\")[0] >>> delegate0[\"username\"] u'binance_staking'","title":"An intuitive REST API"},{"location":"#fast-way-to-interact-with-blockchain","text":">>> import dposlib >>> rest.use(\"dark\") >>> # send 1 token to D7seWn8JLVwX4nHd9hh2Lf7gvZNiRJ7qLk with a simple message >>> tx = dposlib.core.transfer(1, \"D7seWn8JLVwX4nHd9hh2Lf7gvZNiRJ7qLk\", \"message\") >>> # sign tx with secret and [optional second secret] >>> tx.finalize(\"first secret\", \"second secret\") >>> tx { \"amount\": 100000000, \"asset\": {}, \"fee\": 1090241, \"id\": \"1e967879eb134712afd2b2a606be8460468b80aab857fa99a88cf8da0d72bd5d\", \"recipientId\": \"D7seWn8JLVwX4nHd9hh2Lf7gvZNiRJ7qLk\", \"senderId\": \"D7seWn8JLVwX4nHd9hh2Lf7gvZNiRJ7qLk\", \"senderPublicKey\": \"03a02b9d5fdd1307c2ee4652ba54d492d1fd11a7d1bb3f3a44c4a05e79f19de933\", \"signSignature\": \"3045022100a8dd9c50b18002bd6f8ffe9f1c0700cafb95de18670b48fa76afd85c3003a2d202200a1cc102c13857a38d8311a5c80a9222329f0c53f3305c70c91979efd5288d21\", \"signature\": \"304402206576aee7893f3c038d58a6def5180881077531c4b1ebe87e835da2dbe40d0670022064ae37be3f160b0c969459e06912ee619997ccf303e6d919135cdf594a74b77d\", \"timestamp\": 69407340, \"type\": 0, \"vendorField\": \"message\" } >>> # broadcast transaction >>> rest.POST.api.transactions(transactions=[tx]) {'data': {'accept': ['1e967879eb134712afd2b2a606be8460468b80aab857fa99a88cf8da0d72bd5d'], 'broadcast': ['1e967879eb134712afd2b2a606be8460468b80aab857fa99a88cf8da0d72bd5d'], 'excess': [], 'invalid': []}}","title":"Fast way to interact with blockchain"},{"location":"#network-api","text":">>> import dposlib >>> rest.use(\"ark\") >>> dlgt = dposlib.core.api.Delegate(\"arky\") # get delegate by username >>> dlgt.forged {'fees': 3294.7, 'forged': 227230.7, 'rewards': 223936.0} >>> dlgt.address 'ARfDVWZ7Zwkox3ZXtMQQY1HYSANMB88vWE' >>> blk = dlgt.lastBlock # get last forged block >>> blk { \"blockSignature\": \"304402200a496a628c2741537538f0492f9d683d3c4f1b30c8dd03c33ad8fbe79d08b6eb02206cdec7e1210db53a3ca22da30912479ff3644d3a1ed1d878417d5965f34dfd6d\", \"confirmations\": 68, \"generatorId\": \"ARfDVWZ7Zwkox3ZXtMQQY1HYSANMB88vWE\", \"generatorPublicKey\": \"030da05984d579395ce276c0dd6ca0a60140a3c3d964423a04e7abe110d60a15e9\", \"height\": 5862354, \"id\": \"1894085440657345411\", \"numberOfTransactions\": 0, \"payloadHash\": \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\", \"payloadLength\": 0, \"previousBlock\": \"11181074894913507025\", \"reward\": 2.0, \"timestamp\": 47535768, \"totalAmount\": 0.0, \"totalFee\": 0.0, \"totalForged\": 2.0, \"version\": 0 } >>> blk.transactions() [] >>> wlt = dposlib.core.api.Wallet(dlgt.address) # get wallet by address >>> wlt.balance 2537.42979112 >>> for elem in [(tx[\"recipientId\"], tx[\"amount\"]) for tx in wlt.lastTransactions(2)]: ... print(elem) ... ('AHMXV6UdkVxsTwMqeoeqdpotRRmGZZaAtj', 0.08403461) ('AUahWfkfr5J4tYakugRbfow7RWVTK35GPW', 329.32420472) >>> wlt.link(\"secret passphrase here\") >>> wlt.send(1, \"ARfDVWZ7Zwkox3ZXtMQQY1HYSANMB88vWE\") {'transactionIds': ['bbce72e7a76f5f71209c8ab29b4b4299a409241dfc77835150459a34bd5a5c16'], 'success': True}","title":"Network API"},{"location":"#version","text":"","title":"Version"},{"location":"#035-current-work","text":"[x] ledger.com Ark app support [ ] Ark-core v 3.0.x compliancy [ ] entity and business transactions implementation","title":"0.3.5 current work"},{"location":"#034","text":"[x] removed requests dependency [x] multisignature api and app run as system services","title":"0.3.4"},{"location":"#033","text":"[x] offline start fixed [x] api.Wallet fixed [x] added pythonic datetime attribute to Transaction class","title":"0.3.3"},{"location":"#032","text":"[x] better vendorFieldHex field handling [x] dposlib.blockchain.Transaction behaviour improvement [x] tx versioning defined in net module [x] bridge for ark-core 2.5 and 2.6","title":"0.3.2"},{"location":"#031","text":"[x] multisignature client-server api","title":"0.3.1"},{"location":"#030","text":"[x] flake8 compliancy [x] Ark 2.6 compatibility [x] removed package resources dependencies [x] ecdsa lib replaced by builtin secp256k1 [x] added Iop mainnet and devnet [x] Lisk and forks dev stopped [x] ldgr import now optional [x] sphinx doc added","title":"0.3.0"},{"location":"#022","text":"[x] Ark v2.5 headers fix [x] Ark v2.5 BigInt fix [x] packaging improvement [x] rest returnKey behaviour improvement","title":"0.2.2"},{"location":"#021","text":"[x] added lisk blockchain [x] added shift , t.shift and qredit network [x] added .cold data in package distribution [x] transaction types 0 , 1 and 3 added to lisk.v09 network [x] python 2.x compliancy for util.data package","title":"0.2.1"},{"location":"#020","text":"[x] ark.v2 api improvement [x] dposlib.util.misc module improvement [x] upVote/downVote bugfix","title":"0.2.0"},{"location":"#019","text":"[x] travis-ci integration [x] dposlib.core.Transaction interface improvement [x] Ark v1 and v2 cross-dependency removed [x] offline work feature added","title":"0.1.9"},{"location":"#018","text":"[x] added ark v2.4 compatibility [x] api wallet link using getpass library [x] added ledger nano S support (transaction type 0, 1, 2 & 3) [x] peer selection now checks syncing status","title":"0.1.8"},{"location":"#017","text":"[x] added transaction and rest MarkDown documentation files [x] dposlib.core.api is both python 2.x and 3.x compliant [x] added Webhook api (experimental) [x] fee data initialisation improvement [x] transaction broadcasting improvement [x] peer selection improvement [x] Lisk blockchain and forks developpement frozen","title":"0.1.7"},{"location":"#016","text":"[x] Ark-core v 2.1.x compatibility","title":"0.1.6"},{"location":"#015","text":"[x] compatibility with both ark-core v2 devnet and mainnet","title":"0.1.5"},{"location":"#014","text":"[x] Python 2.x compatibility fix [x] dposlib.core.Transaction.sign does not set fees anymore [x] dposlib.core.Transaction.finalize set fees before signature [x] dposlib.core.Transaction fee management improved","title":"0.1.4"},{"location":"#013","text":"[x] REST requests header bugfix (ubuntu)","title":"0.1.3"},{"location":"#012","text":"[x] Packaging improvement","title":"0.1.2"},{"location":"#011","text":"[x] ARK packaging improvement ( v1 and v2 ) [x] LISK packaging improvement ( v09 and v10 ) [x] ARK dynamicFee implementation [x] Network API created","title":"0.1.1"},{"location":"#010","text":"[x] First rebrand","title":"0.1.0"},{"location":"blockchain/","text":"dposlib.ark.v2 # init # init(seed=None) Blockchain initialisation. It stores root values in :mod: cfg modules. stop # stop() Stop daemon initialized by init call. transfer # transfer(amount, address, vendorField=None, expiration=0) Build a transfer transaction. Emoji can be included in transaction vendorField using unicode formating. >>> u\"message with sparkles \\u2728\" Arguments : amount float - transaction amount in ark address str - valid recipient address vendorField str - vendor field message expiration float - time of persistance in hour Returns : transaction object registerSecondSecret # registerSecondSecret(secondSecret) Build a second secret registration transaction. Arguments : secondSecret str - passphrase Returns : transaction object registerSecondPublicKey # registerSecondPublicKey(secondPublicKey) Build a second secret registration transaction. You must own the secret issuing secondPublicKey Arguments : secondPublicKey str - public key as hex string Returns : transaction object registerAsDelegate # registerAsDelegate(username) Build a delegate registration transaction. Arguments : username str - delegate username Returns : transaction object upVote # upVote(*usernames) Build an upvote transaction. Arguments : usernames iterable - delegate usernames as str iterable Returns : transaction object downVote # downVote(*usernames) Build a downvote transaction. Arguments : usernames iterable - delegate usernames as str iterable Returns : transaction object registerMultiSignature # registerMultiSignature(minSig, *publicKeys) Build a multisignature registration transaction. Arguments : minSig int - minimum signature required publicKeys list of str - public key list Returns : transaction object registerIpfs # registerIpfs(ipfs) Build an IPFS registration transaction. Arguments : ipfs str - ipfs DAG Returns : transaction object multiPayment # multiPayment(*pairs, **kwargs) Build multi-payment transaction. Emoji can be included in transaction vendorField using unicode formating. >>> u\"message with sparkles \\u2728\" Arguments : pairs iterable - recipient-amount pair iterable vendorField str - vendor field message Returns : transaction object delegateResignation # delegateResignation() Build a delegate resignation transaction. Returns : transaction object htlcSecret # htlcSecret(secret) Compute an HTLC secret hex string from passphrase. Arguments : secret str - passphrase Returns : transaction object htlcLock # htlcLock(amount, address, secret, expiration=24, vendorField=None) Build an HTLC lock transaction. Emoji can be included in transaction vendorField using unicode formating. >>> u\"message with sparkles \\u2728\" Arguments : amount float - transaction amount in ark address str - valid recipient address secret str - lock passphrase expiration float - transaction validity in hour vendorField str - vendor field message Returns : transaction object htlcClaim # htlcClaim(txid, secret) Build an HTLC claim transaction. Arguments : txid str - htlc lock transaction id secret str - passphrase used by htlc lock transaction Returns : transaction object htlcRefund # htlcRefund(txid) Build an HTLC refund transaction. Arguments : txid str - htlc lock transaction id Returns : transaction object dposlib.ark.v2.api # Wallet Objects # class Wallet(dposlib.blockchain.Wallet) registerIpfs # | @dposlib.blockchain.isLinked | registerIpfs(ipfs) See dposlib.ark.v2.registerIpfs . multiSend # | @dposlib.blockchain.isLinked | multiSend(*pairs, **kwargs) See dposlib.ark.v2.multiPayment . resignate # | @dposlib.blockchain.isLinked | resignate() See dposlib.ark.v2.delegateResignation . sendHtlc # | @dposlib.blockchain.isLinked | sendHtlc(amount, address, secret, expiration=24, vendorField=None) See dposlib.ark.v2.htlcLock . claimHtlc # | @dposlib.blockchain.isLinked | claimHtlc(txid, secret) See dposlib.ark.v2.htlcClaim . refundHtlc # | @dposlib.blockchain.isLinked | refundHtlc(txid) See dposlib.ark.v2.htlcRefund . dposlib.ark.v2.mixin # dposlib.blockchain # isLinked # isLinked(func) Python decorator . First argument of decorated function have to be a Content or an object containing a valid address , _derivationPath or publicKey attribute. It executes the decorated function if the object is correctly linked using dposlib.blockchain.link definition. link # link(cls, secret=None, secondSecret=None) Associates crypto keys into a dposlib.blockchain.Content object according to secrets. If secret or secondSecret are not str , they are considered as None . Arguments : cls Content - content object secret str - secret string secondSecret str - second secret string Returns : True if secret and second secret match unLink # unLink(cls) Remove crypto keys association. JSDict Objects # class JSDict(dict) Read only dictionary with js object behaviour. >>> jsdic = blockchain.JSDict(value=5) >>> jsdic {'value': 5} >>> jsdic.value 5 Content Objects # class Content(object) Live object connected to blockchain. It is initialized with dposlib.rest.GET request. Object is updated every 30s. Endpoint response can be a dict or a list . If it is a list , it is stored in data attribute else all fields are stored as instance attribute. >>> txs = blockchain.Content(rest.GET.api.transactions) >>> txs.data[0][\"timestamp\"] { 'epoch': 121912776, 'unix': 1612013976, 'human': '2021-01-30T13:39:36.000Z' } >>> tx = blockchain.Content( rest.GET.api.transactions, \"d36a164a54df9d1c7889521ece15318d6945e9971fecd0a96a9c18e74e0adbf9\", ) >>> tx.timestamp { 'epoch': 121919704, 'unix': 1612020904, 'human': '2021-01-30T15:35:04.000Z' } >>> tx.amount 212963052 >>> tx.datetime datetime.datetime(2021, 1, 30, 15, 35, 4, tzinfo=<UTC>) datetime # if timestamp attributes exists, return associated python datetime object Wallet Objects # class Wallet(Content) Arguments : fee int or str - set fee level as fee multiplier integer or one of minFee , avgFee , maxFee string fee_included bool - set to True if amout + fee is the total desired out flow delegate # return delegate attributes if wallet is registered as delegate username # return delegate username if wallet is registered as delegate secondPublicKey # return second public key if second signature is set to wallet send # | @isLinked | send(amount, address, vendorField=None) See dposlib.ark.v2.transfer . registerSecondSecret # | @isLinked | registerSecondSecret(secondSecret) See dposlib.ark.v2.registerSecondSecret . registerSecondPublicKey # | @isLinked | registerSecondPublicKey(secondPublicKey) See dposlib.ark.v2.registerSecondPublicKey . registerAsDelegate # | @isLinked | registerAsDelegate(username) See dposlib.ark.v2.registerAsDelegate . upVote # | @isLinked | upVote(*usernames) See dposlib.ark.v2.upVote . downVote # | @isLinked | downVote(*usernames) See dposlib.ark.v2.downVote . dposlib.blockchain.cfg # This module stores blockchain parameters. activeDelegates: aip20: begintime: blockreward: blocktime: broadcast: doffsets: explorer: familly: fees: feestats: headers: hotmode: marker: maxTransactions: maxvote: maxvotepertx: network: peers: ports: pubkeyHash: slip44: symbol: timeout: token: txversion: version: wif: dposlib.blockchain.slots # getTimestamp # getTimestamp(**kw) Return blockchain timestamp from timedelta given as keyword arument. >>> from dposlib.blockchain import slots >>> slots.getTimestamp(days=6, hours=4, minutes=20) dposlib.blockchain.tx # computeDynamicFees # computeDynamicFees(tx, FMULT=None) Compute transaction fees according to AIP 16 . Arguments : tx dict or Transaction - transaction object Returns : fees setFeeIncluded # setFeeIncluded(cls) Arrange amount and fee values so the total arktoshi flow is the desired spent. unsetFeeIncluded # unsetFeeIncluded(cls) Arrange amount and fee values so the total arktoshi flow is the desired spent plus the fee. serialize # serialize(tx, **options) Serialize transaction. Arguments : tx dict or Transaction - transaction object Returns : bytes sequence Transaction Objects # class Transaction(dict) A python dict that implements all the necessities to manually generate valid transactions. feeIncluded # use feeIncluded option useDynamicFee # | @staticmethod | useDynamicFee(value=\"minFee\") Activate and configure dynamic fees parameters. Value can be either an integer defining the fee multiplier constant or a string defining the fee level to use acccording to the 30-days-average. possible values are avgFee minFee (default) and maxFee . Arguments : value str or int - constant or fee multiplier link # | link(secret=None, secondSecret=None) Save public and private keys derived from secrets. This is equivalent to wallet login. it limits number of secret keyboard entries. Arguments : secret str - passphrase secondSecret str - second passphrase setFee # | setFee(value=None) Set fee field manually or according to inner parameters. Arguments : value int - fee value in arktoshi to set manually sign # | sign() Generate the signature field. Private key have to be set first. See link . signSign # | signSign() Generate the signSignature field. Transaction have to be signed and second private key have to be set first. See link . signWithSecret # | signWithSecret(secret) Generate the signature field using passphrase. The associated public and private keys are stored till unlink is called. Arguments : secret str - passphrase signSignWithSecondSecret # | signSignWithSecondSecret(secondSecret) Generate the signSignature field using second passphrase. The associated second public and private keys are stored till unlink is called. Arguments : secondSecret str - second passphrase multiSignWithSecret # | multiSignWithSecret(secret) Add a signature in signatures field. Arguments : index int - signature index secret str - passphrase signWithKeys # | signWithKeys(publicKey, privateKey) Generate the signature field using public and private keys. They are till unlink is called. Arguments : publicKey str - public key as hex string privateKey str - private key as hex string signSignWithKey # | signSignWithKey(secondPrivateKey) Generate the signSignature field using second private key. It is stored till unlink is called. Arguments : secondPrivateKey str - second private key as hex string multiSignWithKey # | multiSignWithKey(privateKey) Add a signature in signatures field according to given index and privateKey. Arguments : privateKey str - private key as hex string identify # | identify() Generate the id field. Transaction have to be signed. finalize # | finalize(secret=None, secondSecret=None, fee=None, fee_included=False) Finalize a transaction by setting fee , signatures and id . Arguments : secret str - passphrase secondSecret str - second passphrase fee int - manually set fee value in satoshi fee_included bool - see Transaction.feeIncluded","title":"Blockchain"},{"location":"blockchain/#dposlibarkv2","text":"","title":"dposlib.ark.v2"},{"location":"blockchain/#init","text":"init(seed=None) Blockchain initialisation. It stores root values in :mod: cfg modules.","title":"init"},{"location":"blockchain/#stop","text":"stop() Stop daemon initialized by init call.","title":"stop"},{"location":"blockchain/#transfer","text":"transfer(amount, address, vendorField=None, expiration=0) Build a transfer transaction. Emoji can be included in transaction vendorField using unicode formating. >>> u\"message with sparkles \\u2728\" Arguments : amount float - transaction amount in ark address str - valid recipient address vendorField str - vendor field message expiration float - time of persistance in hour Returns : transaction object","title":"transfer"},{"location":"blockchain/#registersecondsecret","text":"registerSecondSecret(secondSecret) Build a second secret registration transaction. Arguments : secondSecret str - passphrase Returns : transaction object","title":"registerSecondSecret"},{"location":"blockchain/#registersecondpublickey","text":"registerSecondPublicKey(secondPublicKey) Build a second secret registration transaction. You must own the secret issuing secondPublicKey Arguments : secondPublicKey str - public key as hex string Returns : transaction object","title":"registerSecondPublicKey"},{"location":"blockchain/#registerasdelegate","text":"registerAsDelegate(username) Build a delegate registration transaction. Arguments : username str - delegate username Returns : transaction object","title":"registerAsDelegate"},{"location":"blockchain/#upvote","text":"upVote(*usernames) Build an upvote transaction. Arguments : usernames iterable - delegate usernames as str iterable Returns : transaction object","title":"upVote"},{"location":"blockchain/#downvote","text":"downVote(*usernames) Build a downvote transaction. Arguments : usernames iterable - delegate usernames as str iterable Returns : transaction object","title":"downVote"},{"location":"blockchain/#registermultisignature","text":"registerMultiSignature(minSig, *publicKeys) Build a multisignature registration transaction. Arguments : minSig int - minimum signature required publicKeys list of str - public key list Returns : transaction object","title":"registerMultiSignature"},{"location":"blockchain/#registeripfs","text":"registerIpfs(ipfs) Build an IPFS registration transaction. Arguments : ipfs str - ipfs DAG Returns : transaction object","title":"registerIpfs"},{"location":"blockchain/#multipayment","text":"multiPayment(*pairs, **kwargs) Build multi-payment transaction. Emoji can be included in transaction vendorField using unicode formating. >>> u\"message with sparkles \\u2728\" Arguments : pairs iterable - recipient-amount pair iterable vendorField str - vendor field message Returns : transaction object","title":"multiPayment"},{"location":"blockchain/#delegateresignation","text":"delegateResignation() Build a delegate resignation transaction. Returns : transaction object","title":"delegateResignation"},{"location":"blockchain/#htlcsecret","text":"htlcSecret(secret) Compute an HTLC secret hex string from passphrase. Arguments : secret str - passphrase Returns : transaction object","title":"htlcSecret"},{"location":"blockchain/#htlclock","text":"htlcLock(amount, address, secret, expiration=24, vendorField=None) Build an HTLC lock transaction. Emoji can be included in transaction vendorField using unicode formating. >>> u\"message with sparkles \\u2728\" Arguments : amount float - transaction amount in ark address str - valid recipient address secret str - lock passphrase expiration float - transaction validity in hour vendorField str - vendor field message Returns : transaction object","title":"htlcLock"},{"location":"blockchain/#htlcclaim","text":"htlcClaim(txid, secret) Build an HTLC claim transaction. Arguments : txid str - htlc lock transaction id secret str - passphrase used by htlc lock transaction Returns : transaction object","title":"htlcClaim"},{"location":"blockchain/#htlcrefund","text":"htlcRefund(txid) Build an HTLC refund transaction. Arguments : txid str - htlc lock transaction id Returns : transaction object","title":"htlcRefund"},{"location":"blockchain/#dposlibarkv2api","text":"","title":"dposlib.ark.v2.api"},{"location":"blockchain/#wallet-objects","text":"class Wallet(dposlib.blockchain.Wallet)","title":"Wallet Objects"},{"location":"blockchain/#registeripfs_1","text":"| @dposlib.blockchain.isLinked | registerIpfs(ipfs) See dposlib.ark.v2.registerIpfs .","title":"registerIpfs"},{"location":"blockchain/#multisend","text":"| @dposlib.blockchain.isLinked | multiSend(*pairs, **kwargs) See dposlib.ark.v2.multiPayment .","title":"multiSend"},{"location":"blockchain/#resignate","text":"| @dposlib.blockchain.isLinked | resignate() See dposlib.ark.v2.delegateResignation .","title":"resignate"},{"location":"blockchain/#sendhtlc","text":"| @dposlib.blockchain.isLinked | sendHtlc(amount, address, secret, expiration=24, vendorField=None) See dposlib.ark.v2.htlcLock .","title":"sendHtlc"},{"location":"blockchain/#claimhtlc","text":"| @dposlib.blockchain.isLinked | claimHtlc(txid, secret) See dposlib.ark.v2.htlcClaim .","title":"claimHtlc"},{"location":"blockchain/#refundhtlc","text":"| @dposlib.blockchain.isLinked | refundHtlc(txid) See dposlib.ark.v2.htlcRefund .","title":"refundHtlc"},{"location":"blockchain/#dposlibarkv2mixin","text":"","title":"dposlib.ark.v2.mixin"},{"location":"blockchain/#dposlibblockchain","text":"","title":"dposlib.blockchain"},{"location":"blockchain/#islinked","text":"isLinked(func) Python decorator . First argument of decorated function have to be a Content or an object containing a valid address , _derivationPath or publicKey attribute. It executes the decorated function if the object is correctly linked using dposlib.blockchain.link definition.","title":"isLinked"},{"location":"blockchain/#link","text":"link(cls, secret=None, secondSecret=None) Associates crypto keys into a dposlib.blockchain.Content object according to secrets. If secret or secondSecret are not str , they are considered as None . Arguments : cls Content - content object secret str - secret string secondSecret str - second secret string Returns : True if secret and second secret match","title":"link"},{"location":"blockchain/#unlink","text":"unLink(cls) Remove crypto keys association.","title":"unLink"},{"location":"blockchain/#jsdict-objects","text":"class JSDict(dict) Read only dictionary with js object behaviour. >>> jsdic = blockchain.JSDict(value=5) >>> jsdic {'value': 5} >>> jsdic.value 5","title":"JSDict Objects"},{"location":"blockchain/#content-objects","text":"class Content(object) Live object connected to blockchain. It is initialized with dposlib.rest.GET request. Object is updated every 30s. Endpoint response can be a dict or a list . If it is a list , it is stored in data attribute else all fields are stored as instance attribute. >>> txs = blockchain.Content(rest.GET.api.transactions) >>> txs.data[0][\"timestamp\"] { 'epoch': 121912776, 'unix': 1612013976, 'human': '2021-01-30T13:39:36.000Z' } >>> tx = blockchain.Content( rest.GET.api.transactions, \"d36a164a54df9d1c7889521ece15318d6945e9971fecd0a96a9c18e74e0adbf9\", ) >>> tx.timestamp { 'epoch': 121919704, 'unix': 1612020904, 'human': '2021-01-30T15:35:04.000Z' } >>> tx.amount 212963052 >>> tx.datetime datetime.datetime(2021, 1, 30, 15, 35, 4, tzinfo=<UTC>)","title":"Content Objects"},{"location":"blockchain/#datetime","text":"if timestamp attributes exists, return associated python datetime object","title":"datetime"},{"location":"blockchain/#wallet-objects_1","text":"class Wallet(Content) Arguments : fee int or str - set fee level as fee multiplier integer or one of minFee , avgFee , maxFee string fee_included bool - set to True if amout + fee is the total desired out flow","title":"Wallet Objects"},{"location":"blockchain/#delegate","text":"return delegate attributes if wallet is registered as delegate","title":"delegate"},{"location":"blockchain/#username","text":"return delegate username if wallet is registered as delegate","title":"username"},{"location":"blockchain/#secondpublickey","text":"return second public key if second signature is set to wallet","title":"secondPublicKey"},{"location":"blockchain/#send","text":"| @isLinked | send(amount, address, vendorField=None) See dposlib.ark.v2.transfer .","title":"send"},{"location":"blockchain/#registersecondsecret_1","text":"| @isLinked | registerSecondSecret(secondSecret) See dposlib.ark.v2.registerSecondSecret .","title":"registerSecondSecret"},{"location":"blockchain/#registersecondpublickey_1","text":"| @isLinked | registerSecondPublicKey(secondPublicKey) See dposlib.ark.v2.registerSecondPublicKey .","title":"registerSecondPublicKey"},{"location":"blockchain/#registerasdelegate_1","text":"| @isLinked | registerAsDelegate(username) See dposlib.ark.v2.registerAsDelegate .","title":"registerAsDelegate"},{"location":"blockchain/#upvote_1","text":"| @isLinked | upVote(*usernames) See dposlib.ark.v2.upVote .","title":"upVote"},{"location":"blockchain/#downvote_1","text":"| @isLinked | downVote(*usernames) See dposlib.ark.v2.downVote .","title":"downVote"},{"location":"blockchain/#dposlibblockchaincfg","text":"This module stores blockchain parameters. activeDelegates: aip20: begintime: blockreward: blocktime: broadcast: doffsets: explorer: familly: fees: feestats: headers: hotmode: marker: maxTransactions: maxvote: maxvotepertx: network: peers: ports: pubkeyHash: slip44: symbol: timeout: token: txversion: version: wif:","title":"dposlib.blockchain.cfg"},{"location":"blockchain/#dposlibblockchainslots","text":"","title":"dposlib.blockchain.slots"},{"location":"blockchain/#gettimestamp","text":"getTimestamp(**kw) Return blockchain timestamp from timedelta given as keyword arument. >>> from dposlib.blockchain import slots >>> slots.getTimestamp(days=6, hours=4, minutes=20)","title":"getTimestamp"},{"location":"blockchain/#dposlibblockchaintx","text":"","title":"dposlib.blockchain.tx"},{"location":"blockchain/#computedynamicfees","text":"computeDynamicFees(tx, FMULT=None) Compute transaction fees according to AIP 16 . Arguments : tx dict or Transaction - transaction object Returns : fees","title":"computeDynamicFees"},{"location":"blockchain/#setfeeincluded","text":"setFeeIncluded(cls) Arrange amount and fee values so the total arktoshi flow is the desired spent.","title":"setFeeIncluded"},{"location":"blockchain/#unsetfeeincluded","text":"unsetFeeIncluded(cls) Arrange amount and fee values so the total arktoshi flow is the desired spent plus the fee.","title":"unsetFeeIncluded"},{"location":"blockchain/#serialize","text":"serialize(tx, **options) Serialize transaction. Arguments : tx dict or Transaction - transaction object Returns : bytes sequence","title":"serialize"},{"location":"blockchain/#transaction-objects","text":"class Transaction(dict) A python dict that implements all the necessities to manually generate valid transactions.","title":"Transaction Objects"},{"location":"blockchain/#feeincluded","text":"use feeIncluded option","title":"feeIncluded"},{"location":"blockchain/#usedynamicfee","text":"| @staticmethod | useDynamicFee(value=\"minFee\") Activate and configure dynamic fees parameters. Value can be either an integer defining the fee multiplier constant or a string defining the fee level to use acccording to the 30-days-average. possible values are avgFee minFee (default) and maxFee . Arguments : value str or int - constant or fee multiplier","title":"useDynamicFee"},{"location":"blockchain/#link_1","text":"| link(secret=None, secondSecret=None) Save public and private keys derived from secrets. This is equivalent to wallet login. it limits number of secret keyboard entries. Arguments : secret str - passphrase secondSecret str - second passphrase","title":"link"},{"location":"blockchain/#setfee","text":"| setFee(value=None) Set fee field manually or according to inner parameters. Arguments : value int - fee value in arktoshi to set manually","title":"setFee"},{"location":"blockchain/#sign","text":"| sign() Generate the signature field. Private key have to be set first. See link .","title":"sign"},{"location":"blockchain/#signsign","text":"| signSign() Generate the signSignature field. Transaction have to be signed and second private key have to be set first. See link .","title":"signSign"},{"location":"blockchain/#signwithsecret","text":"| signWithSecret(secret) Generate the signature field using passphrase. The associated public and private keys are stored till unlink is called. Arguments : secret str - passphrase","title":"signWithSecret"},{"location":"blockchain/#signsignwithsecondsecret","text":"| signSignWithSecondSecret(secondSecret) Generate the signSignature field using second passphrase. The associated second public and private keys are stored till unlink is called. Arguments : secondSecret str - second passphrase","title":"signSignWithSecondSecret"},{"location":"blockchain/#multisignwithsecret","text":"| multiSignWithSecret(secret) Add a signature in signatures field. Arguments : index int - signature index secret str - passphrase","title":"multiSignWithSecret"},{"location":"blockchain/#signwithkeys","text":"| signWithKeys(publicKey, privateKey) Generate the signature field using public and private keys. They are till unlink is called. Arguments : publicKey str - public key as hex string privateKey str - private key as hex string","title":"signWithKeys"},{"location":"blockchain/#signsignwithkey","text":"| signSignWithKey(secondPrivateKey) Generate the signSignature field using second private key. It is stored till unlink is called. Arguments : secondPrivateKey str - second private key as hex string","title":"signSignWithKey"},{"location":"blockchain/#multisignwithkey","text":"| multiSignWithKey(privateKey) Add a signature in signatures field according to given index and privateKey. Arguments : privateKey str - private key as hex string","title":"multiSignWithKey"},{"location":"blockchain/#identify","text":"| identify() Generate the id field. Transaction have to be signed.","title":"identify"},{"location":"blockchain/#finalize","text":"| finalize(secret=None, secondSecret=None, fee=None, fee_included=False) Finalize a transaction by setting fee , signatures and id . Arguments : secret str - passphrase secondSecret str - second passphrase fee int - manually set fee value in satoshi fee_included bool - see Transaction.feeIncluded","title":"finalize"},{"location":"crypto/","text":"dposlib.ark.crypto # getKeys # getKeys(secret) Generate keyring containing secp256k1 keys-pair and wallet import format (WIF). Arguments : secret (str, bytes or int): anything that could issue a private key on secp256k1 curve Returns : public, private and WIF keys getMultiSignaturePublicKey # getMultiSignaturePublicKey(minimum, *publicKeys) Compute ARK multi signature public key according to ARK AIP 18 . Arguments : minimum int - minimum signature required publicKeys list of str - public key list Returns : the multisignature public key getAddressFromSecret # getAddressFromSecret(secret, marker=None) Compute ARK address from secret. Arguments : secret str - secret string marker int - network marker (optional) Returns : the address getAddress # getAddress(publicKey, marker=None) Compute ARK address from publicKey. Arguments : publicKey str - public key marker int - network marker (optional) Returns : the address getWIF # getWIF(seed) Compute WIF address from seed. Arguments : seed bytes - a sha256 sequence bytes Returns : WIF address wifSignature # wifSignature(tx, wif) Generate transaction signature using private key. Arguments : tx dict or Transaction - transaction description wif str - wif key Returns : signature wifSignatureFromBytes # wifSignatureFromBytes(data, wif) Generate signature from data using WIF key. Arguments : data bytes - bytes sequence wif str - wif key Returns : signature getSignature # getSignature(tx, privateKey, **options) Generate transaction signature using private key. Arguments : tx dict or Transaction - transaction description privateKey str - private key as hex string Keyword args: exclude_sig (bool): exclude signature during tx serialization [defalut: True] exclude_multi_sig(bool): exclude signatures during tx serialization [defalut: True] exclude_second_sig(bool): exclude second signatures during tx serialization [defalut: True] Returns : signature getSignatureFromBytes # getSignatureFromBytes(data, privateKey) Generate signature from data using private key. Arguments : data bytes - bytes sequence privateKey str - private key as hex string Returns : signature as hex string verifySignature # verifySignature(value, publicKey, signature) Verify signature. Arguments : value str - value as hex string publicKey str - public key as hex string signature str - signature as hex string Returns : True if signature matches the public key verifySignatureFromBytes # verifySignatureFromBytes(data, publicKey, signature) Verify signature. Arguments : data bytes - data publicKey str - public key as hex string signature str - signature as hex string Returns : True if signature matches the public key getId # getId(tx) Generate transaction id. Arguments : tx dict or Transaction - transaction object Returns : id as hex string getIdFromBytes # getIdFromBytes(data) Generate data id. Arguments : data bytes - data as bytes sequence Returns : id as hex string getBytes # getBytes(tx, **options) Hash transaction. Arguments : tx dict or Transaction - transaction object Keyword args: exclude_sig (bool): exclude signature during tx serialization [defalut: True] exclude_multi_sig(bool): exclude signatures during tx serialization [defalut: True] exclude_second_sig(bool): exclude second signatures during tx serialization [defalut: True] Returns : bytes sequence checkTransaction # checkTransaction(tx, secondPublicKey=None, multiPublicKeys=[]) Verify transaction validity. Arguments : tx (dict or Transaction): transaction object secondPublicKey (str): second public key to use if needed multiPublicKeys (list): owners public keys (sorted according to associated type-4-tx asset) Returns : True if transaction is valid dposlib.ark.ldgr # This module contains functions to interoperate with Ledger hard wallet. parseBip44Path # parseBip44Path(path) Parse a BIP44 derivation path. Arguments : path str - the derivation path Returns : parsed bip44 path as bytes buildPukApdu # buildPukApdu(dongle_path) Generate apdu to get public key from ledger key. Arguments : dongle_path bytes - value returned by dposlib.ark.ldgr.parseBip44Path Returns : public key apdu data as bytes getPublicKey # getPublicKey(path=None, debug=False) Compute the public key associated to a derivation path. Arguments : path str - derivation path debug bool - flag to activate debug messages from ledger key Returns : hexadecimal compressed publicKey signMessage # signMessage(msg, path=None, schnorr=True, debug=False) Compute schnorr or ecdsa signature of msg according to derivation path. Arguments : msg str or bytes - transaction as dictionary path str - derivation path schnorr bool - use schnorr signature if True else ecdsa debug bool - flag to activate debug messages from ledger key signTransaction # signTransaction(tx, path=None, schnorr=True, debug=False) Append sender public key and signature into transaction according to derivation path. Arguments : tx dposlib.blockchain.tx.Transaction - transaction path str - derivation path schnorr bool - use schnorr signature if True else ecdsa debug bool - flag to activate debug messages from ledger key","title":"Crypto"},{"location":"crypto/#dposlibarkcrypto","text":"","title":"dposlib.ark.crypto"},{"location":"crypto/#getkeys","text":"getKeys(secret) Generate keyring containing secp256k1 keys-pair and wallet import format (WIF). Arguments : secret (str, bytes or int): anything that could issue a private key on secp256k1 curve Returns : public, private and WIF keys","title":"getKeys"},{"location":"crypto/#getmultisignaturepublickey","text":"getMultiSignaturePublicKey(minimum, *publicKeys) Compute ARK multi signature public key according to ARK AIP 18 . Arguments : minimum int - minimum signature required publicKeys list of str - public key list Returns : the multisignature public key","title":"getMultiSignaturePublicKey"},{"location":"crypto/#getaddressfromsecret","text":"getAddressFromSecret(secret, marker=None) Compute ARK address from secret. Arguments : secret str - secret string marker int - network marker (optional) Returns : the address","title":"getAddressFromSecret"},{"location":"crypto/#getaddress","text":"getAddress(publicKey, marker=None) Compute ARK address from publicKey. Arguments : publicKey str - public key marker int - network marker (optional) Returns : the address","title":"getAddress"},{"location":"crypto/#getwif","text":"getWIF(seed) Compute WIF address from seed. Arguments : seed bytes - a sha256 sequence bytes Returns : WIF address","title":"getWIF"},{"location":"crypto/#wifsignature","text":"wifSignature(tx, wif) Generate transaction signature using private key. Arguments : tx dict or Transaction - transaction description wif str - wif key Returns : signature","title":"wifSignature"},{"location":"crypto/#wifsignaturefrombytes","text":"wifSignatureFromBytes(data, wif) Generate signature from data using WIF key. Arguments : data bytes - bytes sequence wif str - wif key Returns : signature","title":"wifSignatureFromBytes"},{"location":"crypto/#getsignature","text":"getSignature(tx, privateKey, **options) Generate transaction signature using private key. Arguments : tx dict or Transaction - transaction description privateKey str - private key as hex string Keyword args: exclude_sig (bool): exclude signature during tx serialization [defalut: True] exclude_multi_sig(bool): exclude signatures during tx serialization [defalut: True] exclude_second_sig(bool): exclude second signatures during tx serialization [defalut: True] Returns : signature","title":"getSignature"},{"location":"crypto/#getsignaturefrombytes","text":"getSignatureFromBytes(data, privateKey) Generate signature from data using private key. Arguments : data bytes - bytes sequence privateKey str - private key as hex string Returns : signature as hex string","title":"getSignatureFromBytes"},{"location":"crypto/#verifysignature","text":"verifySignature(value, publicKey, signature) Verify signature. Arguments : value str - value as hex string publicKey str - public key as hex string signature str - signature as hex string Returns : True if signature matches the public key","title":"verifySignature"},{"location":"crypto/#verifysignaturefrombytes","text":"verifySignatureFromBytes(data, publicKey, signature) Verify signature. Arguments : data bytes - data publicKey str - public key as hex string signature str - signature as hex string Returns : True if signature matches the public key","title":"verifySignatureFromBytes"},{"location":"crypto/#getid","text":"getId(tx) Generate transaction id. Arguments : tx dict or Transaction - transaction object Returns : id as hex string","title":"getId"},{"location":"crypto/#getidfrombytes","text":"getIdFromBytes(data) Generate data id. Arguments : data bytes - data as bytes sequence Returns : id as hex string","title":"getIdFromBytes"},{"location":"crypto/#getbytes","text":"getBytes(tx, **options) Hash transaction. Arguments : tx dict or Transaction - transaction object Keyword args: exclude_sig (bool): exclude signature during tx serialization [defalut: True] exclude_multi_sig(bool): exclude signatures during tx serialization [defalut: True] exclude_second_sig(bool): exclude second signatures during tx serialization [defalut: True] Returns : bytes sequence","title":"getBytes"},{"location":"crypto/#checktransaction","text":"checkTransaction(tx, secondPublicKey=None, multiPublicKeys=[]) Verify transaction validity. Arguments : tx (dict or Transaction): transaction object secondPublicKey (str): second public key to use if needed multiPublicKeys (list): owners public keys (sorted according to associated type-4-tx asset) Returns : True if transaction is valid","title":"checkTransaction"},{"location":"crypto/#dposlibarkldgr","text":"This module contains functions to interoperate with Ledger hard wallet.","title":"dposlib.ark.ldgr"},{"location":"crypto/#parsebip44path","text":"parseBip44Path(path) Parse a BIP44 derivation path. Arguments : path str - the derivation path Returns : parsed bip44 path as bytes","title":"parseBip44Path"},{"location":"crypto/#buildpukapdu","text":"buildPukApdu(dongle_path) Generate apdu to get public key from ledger key. Arguments : dongle_path bytes - value returned by dposlib.ark.ldgr.parseBip44Path Returns : public key apdu data as bytes","title":"buildPukApdu"},{"location":"crypto/#getpublickey","text":"getPublicKey(path=None, debug=False) Compute the public key associated to a derivation path. Arguments : path str - derivation path debug bool - flag to activate debug messages from ledger key Returns : hexadecimal compressed publicKey","title":"getPublicKey"},{"location":"crypto/#signmessage","text":"signMessage(msg, path=None, schnorr=True, debug=False) Compute schnorr or ecdsa signature of msg according to derivation path. Arguments : msg str or bytes - transaction as dictionary path str - derivation path schnorr bool - use schnorr signature if True else ecdsa debug bool - flag to activate debug messages from ledger key","title":"signMessage"},{"location":"crypto/#signtransaction","text":"signTransaction(tx, path=None, schnorr=True, debug=False) Append sender public key and signature into transaction according to derivation path. Arguments : tx dposlib.blockchain.tx.Transaction - transaction path str - derivation path schnorr bool - use schnorr signature if True else ecdsa debug bool - flag to activate debug messages from ledger key","title":"signTransaction"},{"location":"network/","text":"dposlib.rest # rest module provides network loaders and usrv.get.EndPoint root class to implement GET , POST , PUT and DELETE HTTP requests. See Ark API documentation to see how to use http calls. rest also creates a core module containing dposlib.blockchain.tx.Transaction builders, dposlib.ark.crypto and dposlib.ark.v2.api interface. Use rest HTTP request builder # >>> from dposlib import rest >>> rest.use(\"ark\") True >>> # reach http://api.ark.io/api/delegates/arky endpoint using GET >>> # HTTP request builder >>> rest.GET.api.delegates.arky()[\"username\"] 'arky' Use api and core modules # >>> import dposlib >>> dlgt = dposlib.core.api.Delegate(\"arky\") >>> dlgt.forged {u'rewards': 397594.0, u'total': 401908.71166083, u'fees': 4314.71166083} >>> dposlib.core.crypto.getKeys(\"secret\")[\"publicKey\"] '03a02b9d5fdd1307c2ee4652ba54d492d1fd11a7d1bb3f3a44c4a05e79f19de933' >>> dposlib.core.transfer( ... 1, \"ARfDVWZ7Zwkox3ZXtMQQY1HYSANMB88vWE\", ... u\"\\u2728 simple transfer vendorField\" ... ) { \"amount\": 100000000, \"asset\": {}, \"recipientId\": \"ARfDVWZ7Zwkox3ZXtMQQY1HYSANMB88vWE\", \"type\": 0, \"vendorField\": \"\\u2728 simple transfer vendorField\", \"version\": 1 } >>> dposlib.core.htlcLock( ... 1, \"ARfDVWZ7Zwkox3ZXtMQQY1HYSANMB88vWE\", ... \"my secret lock\", expiration=12, ... vendorField=u\"\\u2728 simple htlcLock vendorField\" ... ) { \"amount\": 100000000, \"asset\": { \"lock\": { \"secretHash\": \"dbaed2f2747c7aa5a834b082ccb2b648648758a98d1a415b2ed9a22fd29d47cb\", \"expiration\": { \"type\": 1, \"value\": 82567745 } } }, \"network\": 23, \"recipientId\": \"ARfDVWZ7Zwkox3ZXtMQQY1HYSANMB88vWE\", \"type\": 8, \"typeGroup\": 1, \"vendorField\": \"\\u2728 simple htlcLock vendorField\", \"version\": 2 } GET # GET HTTP request builder POST # POST HTTP request builder PUT # PUT HTTP request builder DELETE # DELETE HTTP request builder load # load(name) Load a given blockchain package as dposlib.core module. A valid blockchain package must provide init(peer=None) and stop() definitions. Available blockchains are referenced in dposli.net module. Arguments : name str - package name to load use # use(network, **kwargs) Sets the blockchain parameters in the dposlib.rest.cfg module and initializes blockchain package. Network options can be created or overriden using **kwargs argument. Arguments : network str - network to initialize Returns : True if network connection established","title":"Network"},{"location":"network/#dposlibrest","text":"rest module provides network loaders and usrv.get.EndPoint root class to implement GET , POST , PUT and DELETE HTTP requests. See Ark API documentation to see how to use http calls. rest also creates a core module containing dposlib.blockchain.tx.Transaction builders, dposlib.ark.crypto and dposlib.ark.v2.api interface.","title":"dposlib.rest"},{"location":"network/#use-rest-http-request-builder","text":">>> from dposlib import rest >>> rest.use(\"ark\") True >>> # reach http://api.ark.io/api/delegates/arky endpoint using GET >>> # HTTP request builder >>> rest.GET.api.delegates.arky()[\"username\"] 'arky'","title":"Use rest HTTP request builder"},{"location":"network/#use-api-and-core-modules","text":">>> import dposlib >>> dlgt = dposlib.core.api.Delegate(\"arky\") >>> dlgt.forged {u'rewards': 397594.0, u'total': 401908.71166083, u'fees': 4314.71166083} >>> dposlib.core.crypto.getKeys(\"secret\")[\"publicKey\"] '03a02b9d5fdd1307c2ee4652ba54d492d1fd11a7d1bb3f3a44c4a05e79f19de933' >>> dposlib.core.transfer( ... 1, \"ARfDVWZ7Zwkox3ZXtMQQY1HYSANMB88vWE\", ... u\"\\u2728 simple transfer vendorField\" ... ) { \"amount\": 100000000, \"asset\": {}, \"recipientId\": \"ARfDVWZ7Zwkox3ZXtMQQY1HYSANMB88vWE\", \"type\": 0, \"vendorField\": \"\\u2728 simple transfer vendorField\", \"version\": 1 } >>> dposlib.core.htlcLock( ... 1, \"ARfDVWZ7Zwkox3ZXtMQQY1HYSANMB88vWE\", ... \"my secret lock\", expiration=12, ... vendorField=u\"\\u2728 simple htlcLock vendorField\" ... ) { \"amount\": 100000000, \"asset\": { \"lock\": { \"secretHash\": \"dbaed2f2747c7aa5a834b082ccb2b648648758a98d1a415b2ed9a22fd29d47cb\", \"expiration\": { \"type\": 1, \"value\": 82567745 } } }, \"network\": 23, \"recipientId\": \"ARfDVWZ7Zwkox3ZXtMQQY1HYSANMB88vWE\", \"type\": 8, \"typeGroup\": 1, \"vendorField\": \"\\u2728 simple htlcLock vendorField\", \"version\": 2 }","title":"Use api and core modules"},{"location":"network/#get","text":"GET HTTP request builder","title":"GET"},{"location":"network/#post","text":"POST HTTP request builder","title":"POST"},{"location":"network/#put","text":"PUT HTTP request builder","title":"PUT"},{"location":"network/#delete","text":"DELETE HTTP request builder","title":"DELETE"},{"location":"network/#load","text":"load(name) Load a given blockchain package as dposlib.core module. A valid blockchain package must provide init(peer=None) and stop() definitions. Available blockchains are referenced in dposli.net module. Arguments : name str - package name to load","title":"load"},{"location":"network/#use","text":"use(network, **kwargs) Sets the blockchain parameters in the dposlib.rest.cfg module and initializes blockchain package. Network options can be created or overriden using **kwargs argument. Arguments : network str - network to initialize Returns : True if network connection established","title":"use"}]}