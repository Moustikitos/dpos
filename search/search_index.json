{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"dposlib: Ark API for Humans # dposlib is a simple package providing efficient API to interact with Ark blockchain and its forks. It is designed to run with both python 2 and 3. Simplicity of REST API: >>> from dposlib import rest >>> # ~ https://explorer.ark.io:8443/api/delegates/arky >>> rest.GET.api.delegates.arky(peer=\"https://explorer.ark.io:8443\") {u'data': {u'username': u'arky', u'votes': u'172572088664599', u'blocks': {u'produced': 199859, u'last': {u'timestamp': {u'epoch': 84182056, u'unix': 1574283256, u'human': u'2019-11-20T20:54:16.000Z'}, u'id': u'5f5f9897f8fca2a5600ace0d75d67811c67df8111a7deea13d7d6b2c532fae43', u'height': 10380869}}, u'rank': 11, u'publicKey': u'030da05984d579395ce276c0dd6ca0a60140a3c3d964423a04e7abe110d60a15e9', u'production': {u'approval': 1.35}, u'forged': {u'total': u'40118247659340', u'rewards': u'39687400000000', u'fees': u'430847659340'}, u'address': u'ARfDVWZ7Zwkox3ZXtMQQY1HYSANMB88vWE'}} >>> # using returnKey arktoshi values are converted to ark >>> rest.GET.api.transactions(peer=\"https://explorer.ark.io:8443\", returnKey=\"data\")[0] {u'fee': 0.00816, u'type': 0, u'sender': u'AKATy581uXWrbm8B4DTQh4R9RbqaWRiKRY', u'timestamp': {u'epoch': 84182307, u'unix': 1574283507, u'human': u'2019-11-20T20:58:27.000Z'}, u'blockId': u'a1b305a87217c2f622a922a97a778c677f7dbd23031dae42e3b494883b855a70', u'vendorField': u'Payout from arkmoon', u'senderPublicKey': u'0232b96d57ac27f9a99242bc886e433baa89f596d435153c9dae47222c0d1cecc3', u'amount': 20.52064264, u'version': 1, u'signSignature': u'304402200ac41802f33a5f377975efc9ebf39a666a9d76c2facb8773783289df7f6a9cd302206c5d2aed3359d3858fb3f4d5fc2a76952eb518cf9d242bb91fd11c0801e4ea4e', u'confirmations': 21, u'signature': u'3045022100dc6dbaa4b056f10268b587da290900725246e3239df1fa3e3c53445da36f03ee02206d57bbdff6d7f9ebca719a41112f23128f1a84161dd82597d63351e3c4d868b0', u'recipient': u'AXPLW2TzBsXcPiaeVGBSELEAXj4RPaWNjB', u'id': u'efeab09925c3347b4a18854a9192d7d722ee32850a7bf91d57628cb77714192e'} >>> # peer keyword is not mandatory when a blockchain is linked using rest.use directive >>> rest.use(\"ark\") >>> # ~ GET /api/blocks endpoint >>> rest.GET.api.blocks(returnKey=\"data\")[0] {u'payload': {u'length': 0, u'hash': u'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855'}, u'generator': {u'username': u'arkmoon', u'publicKey': u'0232b96d57ac27f9a99242bc886e433baa89f596d435153c9dae47222c0d1cecc3', u'address': u'AKATy581uXWrbm8B4DTQh4R9RbqaWRiKRY'}, u'transactions': 0, u'timestamp': {u'epoch': 84183376, u'unix': 1574284576, u'human': u'2019-11-20T21:16:16.000Z'}, u'height': 10381034, u'version': 0, u'forged': {u'fee': 0.0, u'amount': 0.0, u'total': 2.0, u'reward': 2.0}, u'confirmations': 1, u'signature': u'3045022100a8b6b48c0094f9c84b7da5ae457ca33d5ba0d9a3df963c1e17c42cb52fb563a9022020ea96cf76529943b03b864bbb722352ef6faf5701e36bc16f9903ec2234309b', u'id': u'd2e042495ab64e7cf5bb0fc8d4ce6972a98f29a56d960b707f3c6abd2791a5e2', u'previous': u'ea1b7082424592545860a671a77ef7f59c3730665208080d2481e363be6c1ed0'} ECDSA and SCHNORR signatures can be performed using dposlib.ark.sig and dposlib.ark.crypto modules: >>> import dposlib.ark.sig as sig >>> import dposlib.ark.crypto as crypto >>> keys = crypto.getKeys(\"secret\") >>> keys {'publicKey': '03a02b9d5fdd1307c2ee4652ba54d492d1fd11a7d1bb3f3a44c4a05e79f19de933', 'privateKey': '2bb80d537b1da3e38bd30361aa855686bde0eacd7162fef6a25fe97bf527a25b', 'wif': 'SB3BGPGRh1SRuQd52h7f5jsHUg1G9ATEvSeA7L5Bz4qySQww4k7N'} >>> s = sig.Signature.ecdsa_sign(\"simple message\", keys[\"privateKey\"]) >>> s <secp256k1 signature: r:d811a0321a2e31b0492c1b1b1c4dc3b58055b53cdc9308492b3de71c765f5914 s:4747219a0d74d49a42305c040a91e6a8acd39e6d06b21ec1805bd31c6d871b4f > >>> s.der b\"0D\\x02N\\x13\\x108J\\xd0\\xd6\\xff\\x80'\\xf2\\xf8`\\xd6(\\xb2\\xa6@\\x03\\x0bF#\\xa3\\x93\\xe1\\xdf&\\xf7\\xdd\\xce\\\\u\\x02g\\x8b\\xa9\\x90V\\xaa\\xdf\\xa7\\xf2-;z\\xa5.D\\x8bq8ehG\\xb7\\x11\\x07-`\\xd2\\xd9\\xd3.\\xc4v\" >>> crypto.hexlify(s.der) '3044022041e5aa3da79523a2b342180cb7c04056f8f02e005ea6ec1f14094c66d692f04402200261177cdd88525249a0619d6009adbc6681c250c83748c0cde611f21f543008' >>> crypto.hexlify(s.raw) '4e1310384ad0d6ff8027f2f860d628b2a640030b4623a393e1df26f7ddce5c75678ba99056aadfa7f22d3b7aa52e448b7138656847b711072d60d2d9d32ec476' >>> crypto.hexlify(sig.Signature.schnorr_sign(\"simple message\", keys[\"privateKey\"]).raw) '5fbb0bb00b043400e1fc435c867c738ac80d2c268cd2d61616785315ad330c884a3cfb50bf0da8de9021d42ce2139b6b6547d2bcd884a2da7f5c2e9bfb9cb206' dposlib.ark.v2 package provides dposlib.blockchain.Transaction class and its associated builders: >>> from dposlib import rest >>> rest.use(\"dark\") True >>> from dposlib.ark.v2 import * >>> tx = transfer(1, \"D7seWn8JLVwX4nHd9hh2Lf7gvZNiRJ7qLk\", u\"simple message with sparkle \\u2728\", version=2) >>> tx.finalize(\"first secret\", \"second secret\") >>> tx { \"amount\": 100000000, \"asset\": {}, \"expiration\": 0, \"fee\": 4013642, \"id\": \"041ad1e3dd06d29ef59b2c7e19fea4ced0e7fcf9fdc22edcf26e5cc016e10f38\", \"network\": 30, \"nonce\": 377, \"recipientId\": \"D7seWn8JLVwX4nHd9hh2Lf7gvZNiRJ7qLk\", \"senderId\": \"D7seWn8JLVwX4nHd9hh2Lf7gvZNiRJ7qLk\", \"senderPublicKey\": \"03a02b9d5fdd1307c2ee4652ba54d492d1fd11a7d1bb3f3a44c4a05e79f19de933\", \"signSignature\": \"3d29356c77b63c2d6ce679dad95961b40ea606823bf729a158df5c8378c79c5588ad675ee147a7f77b18518c5bdf9b1a73567d72c3af0bfbe22043b9e1a95e6f\", \"signature\": \"871ac31e7bad08b684b27f1b8a4b9f9f760bb32d1d36cc03e03872edc6070f8d9fec2621ea87e2ea0ae7750e0e7a5db52f39b32e05af76a4331a92e17dbe9f4a\", \"timestamp\": 84186531, \"type\": 0, \"typeGroup\": 1, \"vendorField\": \"simple message with sparkle \\u2728\", \"version\": 2 } >>> broadcastTransactions(tx) {u'data': {u'broadcast': [u'041ad1e3dd06d29ef59b2c7e19fea4ced0e7fcf9fdc22edcf26e5cc016e10f38'], u'invalid': [], u'accept': [u'041ad1e3dd06d29ef59b2c7e19fea4ced0e7fcf9fdc22edcf26e5cc016e10f38'], u'excess': []}}","title":"Home"},{"location":"#dposlib-ark-api-for-humans","text":"dposlib is a simple package providing efficient API to interact with Ark blockchain and its forks. It is designed to run with both python 2 and 3. Simplicity of REST API: >>> from dposlib import rest >>> # ~ https://explorer.ark.io:8443/api/delegates/arky >>> rest.GET.api.delegates.arky(peer=\"https://explorer.ark.io:8443\") {u'data': {u'username': u'arky', u'votes': u'172572088664599', u'blocks': {u'produced': 199859, u'last': {u'timestamp': {u'epoch': 84182056, u'unix': 1574283256, u'human': u'2019-11-20T20:54:16.000Z'}, u'id': u'5f5f9897f8fca2a5600ace0d75d67811c67df8111a7deea13d7d6b2c532fae43', u'height': 10380869}}, u'rank': 11, u'publicKey': u'030da05984d579395ce276c0dd6ca0a60140a3c3d964423a04e7abe110d60a15e9', u'production': {u'approval': 1.35}, u'forged': {u'total': u'40118247659340', u'rewards': u'39687400000000', u'fees': u'430847659340'}, u'address': u'ARfDVWZ7Zwkox3ZXtMQQY1HYSANMB88vWE'}} >>> # using returnKey arktoshi values are converted to ark >>> rest.GET.api.transactions(peer=\"https://explorer.ark.io:8443\", returnKey=\"data\")[0] {u'fee': 0.00816, u'type': 0, u'sender': u'AKATy581uXWrbm8B4DTQh4R9RbqaWRiKRY', u'timestamp': {u'epoch': 84182307, u'unix': 1574283507, u'human': u'2019-11-20T20:58:27.000Z'}, u'blockId': u'a1b305a87217c2f622a922a97a778c677f7dbd23031dae42e3b494883b855a70', u'vendorField': u'Payout from arkmoon', u'senderPublicKey': u'0232b96d57ac27f9a99242bc886e433baa89f596d435153c9dae47222c0d1cecc3', u'amount': 20.52064264, u'version': 1, u'signSignature': u'304402200ac41802f33a5f377975efc9ebf39a666a9d76c2facb8773783289df7f6a9cd302206c5d2aed3359d3858fb3f4d5fc2a76952eb518cf9d242bb91fd11c0801e4ea4e', u'confirmations': 21, u'signature': u'3045022100dc6dbaa4b056f10268b587da290900725246e3239df1fa3e3c53445da36f03ee02206d57bbdff6d7f9ebca719a41112f23128f1a84161dd82597d63351e3c4d868b0', u'recipient': u'AXPLW2TzBsXcPiaeVGBSELEAXj4RPaWNjB', u'id': u'efeab09925c3347b4a18854a9192d7d722ee32850a7bf91d57628cb77714192e'} >>> # peer keyword is not mandatory when a blockchain is linked using rest.use directive >>> rest.use(\"ark\") >>> # ~ GET /api/blocks endpoint >>> rest.GET.api.blocks(returnKey=\"data\")[0] {u'payload': {u'length': 0, u'hash': u'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855'}, u'generator': {u'username': u'arkmoon', u'publicKey': u'0232b96d57ac27f9a99242bc886e433baa89f596d435153c9dae47222c0d1cecc3', u'address': u'AKATy581uXWrbm8B4DTQh4R9RbqaWRiKRY'}, u'transactions': 0, u'timestamp': {u'epoch': 84183376, u'unix': 1574284576, u'human': u'2019-11-20T21:16:16.000Z'}, u'height': 10381034, u'version': 0, u'forged': {u'fee': 0.0, u'amount': 0.0, u'total': 2.0, u'reward': 2.0}, u'confirmations': 1, u'signature': u'3045022100a8b6b48c0094f9c84b7da5ae457ca33d5ba0d9a3df963c1e17c42cb52fb563a9022020ea96cf76529943b03b864bbb722352ef6faf5701e36bc16f9903ec2234309b', u'id': u'd2e042495ab64e7cf5bb0fc8d4ce6972a98f29a56d960b707f3c6abd2791a5e2', u'previous': u'ea1b7082424592545860a671a77ef7f59c3730665208080d2481e363be6c1ed0'} ECDSA and SCHNORR signatures can be performed using dposlib.ark.sig and dposlib.ark.crypto modules: >>> import dposlib.ark.sig as sig >>> import dposlib.ark.crypto as crypto >>> keys = crypto.getKeys(\"secret\") >>> keys {'publicKey': '03a02b9d5fdd1307c2ee4652ba54d492d1fd11a7d1bb3f3a44c4a05e79f19de933', 'privateKey': '2bb80d537b1da3e38bd30361aa855686bde0eacd7162fef6a25fe97bf527a25b', 'wif': 'SB3BGPGRh1SRuQd52h7f5jsHUg1G9ATEvSeA7L5Bz4qySQww4k7N'} >>> s = sig.Signature.ecdsa_sign(\"simple message\", keys[\"privateKey\"]) >>> s <secp256k1 signature: r:d811a0321a2e31b0492c1b1b1c4dc3b58055b53cdc9308492b3de71c765f5914 s:4747219a0d74d49a42305c040a91e6a8acd39e6d06b21ec1805bd31c6d871b4f > >>> s.der b\"0D\\x02N\\x13\\x108J\\xd0\\xd6\\xff\\x80'\\xf2\\xf8`\\xd6(\\xb2\\xa6@\\x03\\x0bF#\\xa3\\x93\\xe1\\xdf&\\xf7\\xdd\\xce\\\\u\\x02g\\x8b\\xa9\\x90V\\xaa\\xdf\\xa7\\xf2-;z\\xa5.D\\x8bq8ehG\\xb7\\x11\\x07-`\\xd2\\xd9\\xd3.\\xc4v\" >>> crypto.hexlify(s.der) '3044022041e5aa3da79523a2b342180cb7c04056f8f02e005ea6ec1f14094c66d692f04402200261177cdd88525249a0619d6009adbc6681c250c83748c0cde611f21f543008' >>> crypto.hexlify(s.raw) '4e1310384ad0d6ff8027f2f860d628b2a640030b4623a393e1df26f7ddce5c75678ba99056aadfa7f22d3b7aa52e448b7138656847b711072d60d2d9d32ec476' >>> crypto.hexlify(sig.Signature.schnorr_sign(\"simple message\", keys[\"privateKey\"]).raw) '5fbb0bb00b043400e1fc435c867c738ac80d2c268cd2d61616785315ad330c884a3cfb50bf0da8de9021d42ce2139b6b6547d2bcd884a2da7f5c2e9bfb9cb206' dposlib.ark.v2 package provides dposlib.blockchain.Transaction class and its associated builders: >>> from dposlib import rest >>> rest.use(\"dark\") True >>> from dposlib.ark.v2 import * >>> tx = transfer(1, \"D7seWn8JLVwX4nHd9hh2Lf7gvZNiRJ7qLk\", u\"simple message with sparkle \\u2728\", version=2) >>> tx.finalize(\"first secret\", \"second secret\") >>> tx { \"amount\": 100000000, \"asset\": {}, \"expiration\": 0, \"fee\": 4013642, \"id\": \"041ad1e3dd06d29ef59b2c7e19fea4ced0e7fcf9fdc22edcf26e5cc016e10f38\", \"network\": 30, \"nonce\": 377, \"recipientId\": \"D7seWn8JLVwX4nHd9hh2Lf7gvZNiRJ7qLk\", \"senderId\": \"D7seWn8JLVwX4nHd9hh2Lf7gvZNiRJ7qLk\", \"senderPublicKey\": \"03a02b9d5fdd1307c2ee4652ba54d492d1fd11a7d1bb3f3a44c4a05e79f19de933\", \"signSignature\": \"3d29356c77b63c2d6ce679dad95961b40ea606823bf729a158df5c8378c79c5588ad675ee147a7f77b18518c5bdf9b1a73567d72c3af0bfbe22043b9e1a95e6f\", \"signature\": \"871ac31e7bad08b684b27f1b8a4b9f9f760bb32d1d36cc03e03872edc6070f8d9fec2621ea87e2ea0ae7750e0e7a5db52f39b32e05af76a4331a92e17dbe9f4a\", \"timestamp\": 84186531, \"type\": 0, \"typeGroup\": 1, \"vendorField\": \"simple message with sparkle \\u2728\", \"version\": 2 } >>> broadcastTransactions(tx) {u'data': {u'broadcast': [u'041ad1e3dd06d29ef59b2c7e19fea4ced0e7fcf9fdc22edcf26e5cc016e10f38'], u'invalid': [], u'accept': [u'041ad1e3dd06d29ef59b2c7e19fea4ced0e7fcf9fdc22edcf26e5cc016e10f38'], u'excess': []}}","title":"dposlib: Ark API for Humans"},{"location":"blockchain/","text":"dposlib.ark.v2 # init # init(seed=None) Blockchain initialisation. It stores root values in rest.cfg modules. stop # stop() Stop daemon initialized by init call. transfer # transfer(amount, address, vendorField=None, expiration=0) Build a transfer transaction. Emoji can be included in transaction vendorField using unicode formating. >>> u\"message with sparkles \\u2728\" Arguments : amount float - transaction amount in ark address str - valid recipient address vendorField str - vendor field message expiration float - time of persistance in hour Returns : transaction object registerSecondSecret # registerSecondSecret(secondSecret) Build a second secret registration transaction. Arguments : secondSecret str - passphrase Returns : transaction object registerSecondPublicKey # registerSecondPublicKey(secondPublicKey) Build a second secret registration transaction. You must own the secret issuing secondPublicKey Arguments : secondPublicKey str - public key as hex string Returns : transaction object registerAsDelegate # registerAsDelegate(username) Build a delegate registration transaction. Arguments : username str - delegate username Returns : transaction object upVote # upVote(*usernames) Build an upvote transaction. Arguments : usernames iterable - delegate usernames as str iterable Returns : transaction object downVote # downVote(*usernames) Build a downvote transaction. Arguments : usernames iterable - delegate usernames as str iterable Returns : transaction object registerMultiSignature # registerMultiSignature(minSig, *publicKeys) Build a multisignature registration transaction. Arguments : minSig int - minimum signature required publicKeys list of str - public key list Returns : transaction object registerIpfs # registerIpfs(ipfs) Build an IPFS registration transaction. Arguments : ipfs str - ipfs DAG Returns : transaction object multiPayment # multiPayment(*pairs, **kwargs) Build multi-payment transaction. Emoji can be included in transaction vendorField using unicode formating. >>> u\"message with sparkles \\u2728\" Arguments : pairs iterable - recipient-amount pair iterable vendorField str - vendor field message Returns : transaction object delegateResignation # delegateResignation() Build a delegate resignation transaction. Returns : transaction object htlcSecret # htlcSecret(secret) Compute an HTLC secret hex string from passphrase. Arguments : secret str - passphrase Returns : transaction object htlcLock # htlcLock(amount, address, secret, expiration=24, vendorField=None) Build an HTLC lock transaction. Emoji can be included in transaction vendorField using unicode formating. >>> u\"message with sparkles \\u2728\" Arguments : amount float - transaction amount in ark address str - valid recipient address secret str - lock passphrase expiration float - transaction validity in hour vendorField str - vendor field message Returns : transaction object htlcClaim # htlcClaim(txid, secret) Build an HTLC claim transaction. Arguments : txid str - htlc lock transaction id secret str - passphrase used by htlc lock transaction Returns : transaction object htlcRefund # htlcRefund(txid) Build an HTLC refund transaction. Arguments : txid str - htlc lock transaction id Returns : transaction object dposlib.ark.v2.api # Wallet Objects # class Wallet(dposlib.blockchain.Wallet) registerIpfs # | @dposlib.blockchain.isLinked | registerIpfs(ipfs) See dposlib.ark.v2.registerIpfs . multiSend # | @dposlib.blockchain.isLinked | multiSend(*pairs, **kwargs) See dposlib.ark.v2.multiPayment . resignate # | @dposlib.blockchain.isLinked | resignate() See dposlib.ark.v2.delegateResignation . sendHtlc # | @dposlib.blockchain.isLinked | sendHtlc(amount, address, secret, expiration=24, vendorField=None) See dposlib.ark.v2.htlcLock . claimHtlc # | @dposlib.blockchain.isLinked | claimHtlc(txid, secret) See dposlib.ark.v2.htlcClaim . refundHtlc # | @dposlib.blockchain.isLinked | refundHtlc(txid) See dposlib.ark.v2.htlcRefund . dposlib.blockchain # isLinked # isLinked(func) Python decorator . First argument of decorated function have to be a Content or an object containing a valid address , _derivationPath or publicKey attribute. It executes the decorated function if the object is correctly linked using dposlib.blockchain.link definition. link # link(cls, secret=None, secondSecret=None) Associates crypto keys into a dposlib.blockchain.Content object according to secrets. If secret or secondSecret are not str , they are considered as None . Arguments : cls Content - content object secret str - secret string secondSecret str - second secret string Returns : True if secret and second secret match unLink # unLink(cls) Remove crypto keys association. JSDict Objects # class JSDict(dict) Read only dictionary with js object behaviour. >>> jsdic = blockchain.JSDict(value=5) >>> jsdic {'value': 5} >>> jsdic.value 5 Content Objects # class Content(object) Live object connected to blockchain. It is initialized with dposlib.rest.GET request. Object is updated every 30s. Endpoint response can be a dict or a list . If it is a list , it is stored in data attribute else all fields are stored as instance attribute. >>> txs = blockchain.Content(rest.GET.api.transactions) >>> txs.data[0][\"timestamp\"] { 'epoch': 121912776, 'unix': 1612013976, 'human': '2021-01-30T13:39:36.000Z' } >>> tx = blockchain.Content( rest.GET.api.transactions, \"d36a164a54df9d1c7889521ece15318d6945e9971fecd0a96a9c18e74e0adbf9\", ) >>> tx.timestamp { 'epoch': 121919704, 'unix': 1612020904, 'human': '2021-01-30T15:35:04.000Z' } >>> tx.amount 212963052 >>> tx.datetime datetime.datetime(2021, 1, 30, 15, 35, 4, tzinfo=<UTC>) datetime # if timestamp attributes exists, return associated python datetime object Wallet Objects # class Wallet(Content) Arguments : fee int or str - set fee level as fee multiplier integer or one of minFee , avgFee , maxFee string fee_included bool - set to True if amout + fee is the total desired out flow delegate # return delegate attributes if wallet is registered as delegate username # return delegate username if wallet is registered as delegate secondPublicKey # return second public key if second signature is set to wallet send # | @isLinked | send(amount, address, vendorField=None) See dposlib.ark.v2.transfer . registerSecondSecret # | @isLinked | registerSecondSecret(secondSecret) See dposlib.ark.v2.registerSecondSecret . registerSecondPublicKey # | @isLinked | registerSecondPublicKey(secondPublicKey) See dposlib.ark.v2.registerSecondPublicKey . registerAsDelegate # | @isLinked | registerAsDelegate(username) See dposlib.ark.v2.registerAsDelegate . upVote # | @isLinked | upVote(*usernames) See dposlib.ark.v2.upVote . downVote # | @isLinked | downVote(*usernames) See dposlib.ark.v2.downVote . dposlib.blockchain.cfg # This module stores blockchain parameters. activeDelegates: aip20: begintime: blockreward: blocktime: broadcast: doffsets: explorer: familly: fees: feestats: headers: hotmode: marker: maxTransactions: maxvote: maxvotepertx: network: peers: ports: pubkeyHash: slip44: symbol: timeout: token: txversion: version: wif: dposlib.blockchain.tx # computeDynamicFees # computeDynamicFees(tx, FMULT=None) Compute transaction fees according to AIP 16 . Arguments : tx dict or Transaction - transaction object Returns : fees setFeeIncluded # setFeeIncluded(cls) Arrange amount and fee values so the total arktoshi flow is the desired spent. unsetFeeIncluded # unsetFeeIncluded(cls) Arrange amount and fee values so the total arktoshi flow is the desired spent plus the fee. serialize # serialize(tx, **options) Serialize transaction. Arguments : tx dict or Transaction - transaction object Returns : bytes sequence Transaction Objects # class Transaction(dict) A python dict that implements all the necessities to manually generate valid transactions. feeIncluded # use feeIncluded option useDynamicFee # | @staticmethod | useDynamicFee(value=\"minFee\") Activate and configure dynamic fees parameters. Value can be either an integer defining the fee multiplier constant or a string defining the fee level to use acccording to the 30-days-average. possible values are avgFee minFee (default) and maxFee . Arguments : value str or int - constant or fee multiplier link # | link(secret=None, secondSecret=None) Save public and private keys derived from secrets. This is equivalent to wallet login. it limits number of secret keyboard entries. Arguments : secret str - passphrase secondSecret str - second passphrase setFee # | setFee(value=None) Set fee field manually or according to inner parameters. Arguments : value int - fee value in arktoshi to set manually sign # | sign() Generate the signature field. Private key have to be set first. See link . signSign # | signSign() Generate the signSignature field. Transaction have to be signed and second private key have to be set first. See link . signWithSecret # | signWithSecret(secret) Generate the signature field using passphrase. The associated public and private keys are stored till unlink is called. Arguments : secret str - passphrase signSignWithSecondSecret # | signSignWithSecondSecret(secondSecret) Generate the signSignature field using second passphrase. The associated second public and private keys are stored till unlink is called. Arguments : secondSecret str - second passphrase multiSignWithSecret # | multiSignWithSecret(secret) Add a signature in signatures field. Arguments : index int - signature index secret str - passphrase signWithKeys # | signWithKeys(publicKey, privateKey) Generate the signature field using public and private keys. They are till unlink is called. Arguments : publicKey str - public key as hex string privateKey str - private key as hex string signSignWithKey # | signSignWithKey(secondPrivateKey) Generate the signSignature field using second private key. It is stored till unlink is called. Arguments : secondPrivateKey str - second private key as hex string multiSignWithKey # | multiSignWithKey(privateKey) Add a signature in signatures field according to given index and privateKey. Arguments : privateKey str - private key as hex string identify # | identify() Generate the id field. Transaction have to be signed. finalize # | finalize(secret=None, secondSecret=None, fee=None, fee_included=False) Finalize a transaction by setting fee , signatures and id . Arguments : secret str - passphrase secondSecret str - second passphrase fee int - manually set fee value in satoshi fee_included bool - see Transaction.feeIncluded","title":"Blockchain"},{"location":"blockchain/#dposlibarkv2","text":"","title":"dposlib.ark.v2"},{"location":"blockchain/#init","text":"init(seed=None) Blockchain initialisation. It stores root values in rest.cfg modules.","title":"init"},{"location":"blockchain/#stop","text":"stop() Stop daemon initialized by init call.","title":"stop"},{"location":"blockchain/#transfer","text":"transfer(amount, address, vendorField=None, expiration=0) Build a transfer transaction. Emoji can be included in transaction vendorField using unicode formating. >>> u\"message with sparkles \\u2728\" Arguments : amount float - transaction amount in ark address str - valid recipient address vendorField str - vendor field message expiration float - time of persistance in hour Returns : transaction object","title":"transfer"},{"location":"blockchain/#registersecondsecret","text":"registerSecondSecret(secondSecret) Build a second secret registration transaction. Arguments : secondSecret str - passphrase Returns : transaction object","title":"registerSecondSecret"},{"location":"blockchain/#registersecondpublickey","text":"registerSecondPublicKey(secondPublicKey) Build a second secret registration transaction. You must own the secret issuing secondPublicKey Arguments : secondPublicKey str - public key as hex string Returns : transaction object","title":"registerSecondPublicKey"},{"location":"blockchain/#registerasdelegate","text":"registerAsDelegate(username) Build a delegate registration transaction. Arguments : username str - delegate username Returns : transaction object","title":"registerAsDelegate"},{"location":"blockchain/#upvote","text":"upVote(*usernames) Build an upvote transaction. Arguments : usernames iterable - delegate usernames as str iterable Returns : transaction object","title":"upVote"},{"location":"blockchain/#downvote","text":"downVote(*usernames) Build a downvote transaction. Arguments : usernames iterable - delegate usernames as str iterable Returns : transaction object","title":"downVote"},{"location":"blockchain/#registermultisignature","text":"registerMultiSignature(minSig, *publicKeys) Build a multisignature registration transaction. Arguments : minSig int - minimum signature required publicKeys list of str - public key list Returns : transaction object","title":"registerMultiSignature"},{"location":"blockchain/#registeripfs","text":"registerIpfs(ipfs) Build an IPFS registration transaction. Arguments : ipfs str - ipfs DAG Returns : transaction object","title":"registerIpfs"},{"location":"blockchain/#multipayment","text":"multiPayment(*pairs, **kwargs) Build multi-payment transaction. Emoji can be included in transaction vendorField using unicode formating. >>> u\"message with sparkles \\u2728\" Arguments : pairs iterable - recipient-amount pair iterable vendorField str - vendor field message Returns : transaction object","title":"multiPayment"},{"location":"blockchain/#delegateresignation","text":"delegateResignation() Build a delegate resignation transaction. Returns : transaction object","title":"delegateResignation"},{"location":"blockchain/#htlcsecret","text":"htlcSecret(secret) Compute an HTLC secret hex string from passphrase. Arguments : secret str - passphrase Returns : transaction object","title":"htlcSecret"},{"location":"blockchain/#htlclock","text":"htlcLock(amount, address, secret, expiration=24, vendorField=None) Build an HTLC lock transaction. Emoji can be included in transaction vendorField using unicode formating. >>> u\"message with sparkles \\u2728\" Arguments : amount float - transaction amount in ark address str - valid recipient address secret str - lock passphrase expiration float - transaction validity in hour vendorField str - vendor field message Returns : transaction object","title":"htlcLock"},{"location":"blockchain/#htlcclaim","text":"htlcClaim(txid, secret) Build an HTLC claim transaction. Arguments : txid str - htlc lock transaction id secret str - passphrase used by htlc lock transaction Returns : transaction object","title":"htlcClaim"},{"location":"blockchain/#htlcrefund","text":"htlcRefund(txid) Build an HTLC refund transaction. Arguments : txid str - htlc lock transaction id Returns : transaction object","title":"htlcRefund"},{"location":"blockchain/#dposlibarkv2api","text":"","title":"dposlib.ark.v2.api"},{"location":"blockchain/#wallet-objects","text":"class Wallet(dposlib.blockchain.Wallet)","title":"Wallet Objects"},{"location":"blockchain/#registeripfs_1","text":"| @dposlib.blockchain.isLinked | registerIpfs(ipfs) See dposlib.ark.v2.registerIpfs .","title":"registerIpfs"},{"location":"blockchain/#multisend","text":"| @dposlib.blockchain.isLinked | multiSend(*pairs, **kwargs) See dposlib.ark.v2.multiPayment .","title":"multiSend"},{"location":"blockchain/#resignate","text":"| @dposlib.blockchain.isLinked | resignate() See dposlib.ark.v2.delegateResignation .","title":"resignate"},{"location":"blockchain/#sendhtlc","text":"| @dposlib.blockchain.isLinked | sendHtlc(amount, address, secret, expiration=24, vendorField=None) See dposlib.ark.v2.htlcLock .","title":"sendHtlc"},{"location":"blockchain/#claimhtlc","text":"| @dposlib.blockchain.isLinked | claimHtlc(txid, secret) See dposlib.ark.v2.htlcClaim .","title":"claimHtlc"},{"location":"blockchain/#refundhtlc","text":"| @dposlib.blockchain.isLinked | refundHtlc(txid) See dposlib.ark.v2.htlcRefund .","title":"refundHtlc"},{"location":"blockchain/#dposlibblockchain","text":"","title":"dposlib.blockchain"},{"location":"blockchain/#islinked","text":"isLinked(func) Python decorator . First argument of decorated function have to be a Content or an object containing a valid address , _derivationPath or publicKey attribute. It executes the decorated function if the object is correctly linked using dposlib.blockchain.link definition.","title":"isLinked"},{"location":"blockchain/#link","text":"link(cls, secret=None, secondSecret=None) Associates crypto keys into a dposlib.blockchain.Content object according to secrets. If secret or secondSecret are not str , they are considered as None . Arguments : cls Content - content object secret str - secret string secondSecret str - second secret string Returns : True if secret and second secret match","title":"link"},{"location":"blockchain/#unlink","text":"unLink(cls) Remove crypto keys association.","title":"unLink"},{"location":"blockchain/#jsdict-objects","text":"class JSDict(dict) Read only dictionary with js object behaviour. >>> jsdic = blockchain.JSDict(value=5) >>> jsdic {'value': 5} >>> jsdic.value 5","title":"JSDict Objects"},{"location":"blockchain/#content-objects","text":"class Content(object) Live object connected to blockchain. It is initialized with dposlib.rest.GET request. Object is updated every 30s. Endpoint response can be a dict or a list . If it is a list , it is stored in data attribute else all fields are stored as instance attribute. >>> txs = blockchain.Content(rest.GET.api.transactions) >>> txs.data[0][\"timestamp\"] { 'epoch': 121912776, 'unix': 1612013976, 'human': '2021-01-30T13:39:36.000Z' } >>> tx = blockchain.Content( rest.GET.api.transactions, \"d36a164a54df9d1c7889521ece15318d6945e9971fecd0a96a9c18e74e0adbf9\", ) >>> tx.timestamp { 'epoch': 121919704, 'unix': 1612020904, 'human': '2021-01-30T15:35:04.000Z' } >>> tx.amount 212963052 >>> tx.datetime datetime.datetime(2021, 1, 30, 15, 35, 4, tzinfo=<UTC>)","title":"Content Objects"},{"location":"blockchain/#datetime","text":"if timestamp attributes exists, return associated python datetime object","title":"datetime"},{"location":"blockchain/#wallet-objects_1","text":"class Wallet(Content) Arguments : fee int or str - set fee level as fee multiplier integer or one of minFee , avgFee , maxFee string fee_included bool - set to True if amout + fee is the total desired out flow","title":"Wallet Objects"},{"location":"blockchain/#delegate","text":"return delegate attributes if wallet is registered as delegate","title":"delegate"},{"location":"blockchain/#username","text":"return delegate username if wallet is registered as delegate","title":"username"},{"location":"blockchain/#secondpublickey","text":"return second public key if second signature is set to wallet","title":"secondPublicKey"},{"location":"blockchain/#send","text":"| @isLinked | send(amount, address, vendorField=None) See dposlib.ark.v2.transfer .","title":"send"},{"location":"blockchain/#registersecondsecret_1","text":"| @isLinked | registerSecondSecret(secondSecret) See dposlib.ark.v2.registerSecondSecret .","title":"registerSecondSecret"},{"location":"blockchain/#registersecondpublickey_1","text":"| @isLinked | registerSecondPublicKey(secondPublicKey) See dposlib.ark.v2.registerSecondPublicKey .","title":"registerSecondPublicKey"},{"location":"blockchain/#registerasdelegate_1","text":"| @isLinked | registerAsDelegate(username) See dposlib.ark.v2.registerAsDelegate .","title":"registerAsDelegate"},{"location":"blockchain/#upvote_1","text":"| @isLinked | upVote(*usernames) See dposlib.ark.v2.upVote .","title":"upVote"},{"location":"blockchain/#downvote_1","text":"| @isLinked | downVote(*usernames) See dposlib.ark.v2.downVote .","title":"downVote"},{"location":"blockchain/#dposlibblockchaincfg","text":"This module stores blockchain parameters. activeDelegates: aip20: begintime: blockreward: blocktime: broadcast: doffsets: explorer: familly: fees: feestats: headers: hotmode: marker: maxTransactions: maxvote: maxvotepertx: network: peers: ports: pubkeyHash: slip44: symbol: timeout: token: txversion: version: wif:","title":"dposlib.blockchain.cfg"},{"location":"blockchain/#dposlibblockchaintx","text":"","title":"dposlib.blockchain.tx"},{"location":"blockchain/#computedynamicfees","text":"computeDynamicFees(tx, FMULT=None) Compute transaction fees according to AIP 16 . Arguments : tx dict or Transaction - transaction object Returns : fees","title":"computeDynamicFees"},{"location":"blockchain/#setfeeincluded","text":"setFeeIncluded(cls) Arrange amount and fee values so the total arktoshi flow is the desired spent.","title":"setFeeIncluded"},{"location":"blockchain/#unsetfeeincluded","text":"unsetFeeIncluded(cls) Arrange amount and fee values so the total arktoshi flow is the desired spent plus the fee.","title":"unsetFeeIncluded"},{"location":"blockchain/#serialize","text":"serialize(tx, **options) Serialize transaction. Arguments : tx dict or Transaction - transaction object Returns : bytes sequence","title":"serialize"},{"location":"blockchain/#transaction-objects","text":"class Transaction(dict) A python dict that implements all the necessities to manually generate valid transactions.","title":"Transaction Objects"},{"location":"blockchain/#feeincluded","text":"use feeIncluded option","title":"feeIncluded"},{"location":"blockchain/#usedynamicfee","text":"| @staticmethod | useDynamicFee(value=\"minFee\") Activate and configure dynamic fees parameters. Value can be either an integer defining the fee multiplier constant or a string defining the fee level to use acccording to the 30-days-average. possible values are avgFee minFee (default) and maxFee . Arguments : value str or int - constant or fee multiplier","title":"useDynamicFee"},{"location":"blockchain/#link_1","text":"| link(secret=None, secondSecret=None) Save public and private keys derived from secrets. This is equivalent to wallet login. it limits number of secret keyboard entries. Arguments : secret str - passphrase secondSecret str - second passphrase","title":"link"},{"location":"blockchain/#setfee","text":"| setFee(value=None) Set fee field manually or according to inner parameters. Arguments : value int - fee value in arktoshi to set manually","title":"setFee"},{"location":"blockchain/#sign","text":"| sign() Generate the signature field. Private key have to be set first. See link .","title":"sign"},{"location":"blockchain/#signsign","text":"| signSign() Generate the signSignature field. Transaction have to be signed and second private key have to be set first. See link .","title":"signSign"},{"location":"blockchain/#signwithsecret","text":"| signWithSecret(secret) Generate the signature field using passphrase. The associated public and private keys are stored till unlink is called. Arguments : secret str - passphrase","title":"signWithSecret"},{"location":"blockchain/#signsignwithsecondsecret","text":"| signSignWithSecondSecret(secondSecret) Generate the signSignature field using second passphrase. The associated second public and private keys are stored till unlink is called. Arguments : secondSecret str - second passphrase","title":"signSignWithSecondSecret"},{"location":"blockchain/#multisignwithsecret","text":"| multiSignWithSecret(secret) Add a signature in signatures field. Arguments : index int - signature index secret str - passphrase","title":"multiSignWithSecret"},{"location":"blockchain/#signwithkeys","text":"| signWithKeys(publicKey, privateKey) Generate the signature field using public and private keys. They are till unlink is called. Arguments : publicKey str - public key as hex string privateKey str - private key as hex string","title":"signWithKeys"},{"location":"blockchain/#signsignwithkey","text":"| signSignWithKey(secondPrivateKey) Generate the signSignature field using second private key. It is stored till unlink is called. Arguments : secondPrivateKey str - second private key as hex string","title":"signSignWithKey"},{"location":"blockchain/#multisignwithkey","text":"| multiSignWithKey(privateKey) Add a signature in signatures field according to given index and privateKey. Arguments : privateKey str - private key as hex string","title":"multiSignWithKey"},{"location":"blockchain/#identify","text":"| identify() Generate the id field. Transaction have to be signed.","title":"identify"},{"location":"blockchain/#finalize","text":"| finalize(secret=None, secondSecret=None, fee=None, fee_included=False) Finalize a transaction by setting fee , signatures and id . Arguments : secret str - passphrase secondSecret str - second passphrase fee int - manually set fee value in satoshi fee_included bool - see Transaction.feeIncluded","title":"finalize"},{"location":"crypto/","text":"dposlib.ark.crypto # getKeys # getKeys(secret) Generate keyring containing secp256k1 keys-pair and wallet import format (WIF). Arguments : secret str, bytes or int - anything that could issue a private key on secp256k1 curve Returns : public, private and WIF keys getMultiSignaturePublicKey # getMultiSignaturePublicKey(minimum, *publicKeys) Compute ARK multi signature public key according to ARK AIP 18 . Arguments : minimum int - minimum signature required publicKeys list of str - public key list Returns : the multisignature public key getAddressFromSecret # getAddressFromSecret(secret, marker=None) Compute ARK address from secret. Arguments : secret str - secret string marker int - network marker (optional) Returns : the address getAddress # getAddress(publicKey, marker=None) Compute ARK address from publicKey. Arguments : publicKey str - public key marker int - network marker (optional) Returns : the address getWIF # getWIF(seed) Compute WIF address from seed. Arguments : seed bytes - a sha256 sequence bytes Returns : WIF address wifSignature # wifSignature(tx, wif) Generate transaction signature using private key. Arguments : tx dict or Transaction - transaction description wif str - wif key Returns : signature wifSignatureFromBytes # wifSignatureFromBytes(data, wif) Generate signature from data using WIF key. Arguments : data bytes - bytes sequence wif str - wif key Returns : signature getSignature # getSignature(tx, privateKey, **options) Generate transaction signature using private key. Arguments : tx dict or Transaction - transaction description privateKey str - private key as hex string Keyword args: exclude_sig (bool): exclude signature during tx serialization [defalut: True] exclude_multi_sig(bool): exclude signatures during tx serialization [defalut: True] exclude_second_sig(bool): exclude second signatures during tx serialization [defalut: True] Returns : signature getSignatureFromBytes # getSignatureFromBytes(data, privateKey) Generate signature from data using private key. Arguments : data bytes - bytes sequence privateKey str - private key as hex string Returns : signature as hex string verifySignature # verifySignature(value, publicKey, signature) Verify signature. Arguments : value str - value as hex string publicKey str - public key as hex string signature str - signature as hex string Returns : True if signature matches the public key verifySignatureFromBytes # verifySignatureFromBytes(data, publicKey, signature) Verify signature. Arguments : data bytes - data publicKey str - public key as hex string signature str - signature as hex string Returns : True if signature matches the public key getId # getId(tx) Generate transaction id. Arguments : tx dict or Transaction - transaction object Returns : id as hex string getIdFromBytes # getIdFromBytes(data) Generate data id. Arguments : data bytes - data as bytes sequence Returns : id as hex string getBytes # getBytes(tx, **options) Hash transaction. Arguments : tx dict or Transaction - transaction object Keyword args: exclude_sig (bool): exclude signature during tx serialization [defalut: True] exclude_multi_sig(bool): exclude signatures during tx serialization [defalut: True] exclude_second_sig(bool): exclude second signatures during tx serialization [defalut: True] Returns : bytes sequence checkTransaction # checkTransaction(tx, secondPublicKey=None, multiPublicKeys=[]) Verify transaction validity. Arguments : tx (dict or Transaction): transaction object secondPublicKey (str): second public key to use if needed multiPublicKeys (list): owners public keys (sorted according to associated type-4-tx asset) Returns : True if transaction is valid dposlib.ark.ldgr # This module contains functions to interoperate with Ledger hard wallet. parseBip44Path # parseBip44Path(path) Parse a BIP44 derivation path. Arguments : path str - the derivation path Returns : parsed bip44 path as bytes buildPukApdu # buildPukApdu(dongle_path) Generate apdu to get public key from ledger key. Arguments : dongle_path bytes - value returned by dposlib.ark.ldgr.parseBip44Path Returns : public key apdu data as bytes getPublicKey # getPublicKey(path=None, debug=False) Compute the public key associated to a derivation path. Arguments : path str - derivation path debug bool - flag to activate debug messages from ledger key Returns : hexadecimal compressed publicKey signMessage # signMessage(msg, path=None, schnorr=True, debug=False) Compute schnorr or ecdsa signature of msg according to derivation path. Arguments : msg str or bytes - transaction as dictionary path str - derivation path schnorr bool - use schnorr signature if True else ecdsa debug bool - flag to activate debug messages from ledger key signTransaction # signTransaction(tx, path=None, schnorr=True, debug=False) Append sender public key and signature into transaction according to derivation path. Arguments : tx dposlib.blockchain.tx.Transaction - transaction path str - derivation path schnorr bool - use schnorr signature if True else ecdsa debug bool - flag to activate debug messages from ledger key","title":"Crypto"},{"location":"crypto/#dposlibarkcrypto","text":"","title":"dposlib.ark.crypto"},{"location":"crypto/#getkeys","text":"getKeys(secret) Generate keyring containing secp256k1 keys-pair and wallet import format (WIF). Arguments : secret str, bytes or int - anything that could issue a private key on secp256k1 curve Returns : public, private and WIF keys","title":"getKeys"},{"location":"crypto/#getmultisignaturepublickey","text":"getMultiSignaturePublicKey(minimum, *publicKeys) Compute ARK multi signature public key according to ARK AIP 18 . Arguments : minimum int - minimum signature required publicKeys list of str - public key list Returns : the multisignature public key","title":"getMultiSignaturePublicKey"},{"location":"crypto/#getaddressfromsecret","text":"getAddressFromSecret(secret, marker=None) Compute ARK address from secret. Arguments : secret str - secret string marker int - network marker (optional) Returns : the address","title":"getAddressFromSecret"},{"location":"crypto/#getaddress","text":"getAddress(publicKey, marker=None) Compute ARK address from publicKey. Arguments : publicKey str - public key marker int - network marker (optional) Returns : the address","title":"getAddress"},{"location":"crypto/#getwif","text":"getWIF(seed) Compute WIF address from seed. Arguments : seed bytes - a sha256 sequence bytes Returns : WIF address","title":"getWIF"},{"location":"crypto/#wifsignature","text":"wifSignature(tx, wif) Generate transaction signature using private key. Arguments : tx dict or Transaction - transaction description wif str - wif key Returns : signature","title":"wifSignature"},{"location":"crypto/#wifsignaturefrombytes","text":"wifSignatureFromBytes(data, wif) Generate signature from data using WIF key. Arguments : data bytes - bytes sequence wif str - wif key Returns : signature","title":"wifSignatureFromBytes"},{"location":"crypto/#getsignature","text":"getSignature(tx, privateKey, **options) Generate transaction signature using private key. Arguments : tx dict or Transaction - transaction description privateKey str - private key as hex string Keyword args: exclude_sig (bool): exclude signature during tx serialization [defalut: True] exclude_multi_sig(bool): exclude signatures during tx serialization [defalut: True] exclude_second_sig(bool): exclude second signatures during tx serialization [defalut: True] Returns : signature","title":"getSignature"},{"location":"crypto/#getsignaturefrombytes","text":"getSignatureFromBytes(data, privateKey) Generate signature from data using private key. Arguments : data bytes - bytes sequence privateKey str - private key as hex string Returns : signature as hex string","title":"getSignatureFromBytes"},{"location":"crypto/#verifysignature","text":"verifySignature(value, publicKey, signature) Verify signature. Arguments : value str - value as hex string publicKey str - public key as hex string signature str - signature as hex string Returns : True if signature matches the public key","title":"verifySignature"},{"location":"crypto/#verifysignaturefrombytes","text":"verifySignatureFromBytes(data, publicKey, signature) Verify signature. Arguments : data bytes - data publicKey str - public key as hex string signature str - signature as hex string Returns : True if signature matches the public key","title":"verifySignatureFromBytes"},{"location":"crypto/#getid","text":"getId(tx) Generate transaction id. Arguments : tx dict or Transaction - transaction object Returns : id as hex string","title":"getId"},{"location":"crypto/#getidfrombytes","text":"getIdFromBytes(data) Generate data id. Arguments : data bytes - data as bytes sequence Returns : id as hex string","title":"getIdFromBytes"},{"location":"crypto/#getbytes","text":"getBytes(tx, **options) Hash transaction. Arguments : tx dict or Transaction - transaction object Keyword args: exclude_sig (bool): exclude signature during tx serialization [defalut: True] exclude_multi_sig(bool): exclude signatures during tx serialization [defalut: True] exclude_second_sig(bool): exclude second signatures during tx serialization [defalut: True] Returns : bytes sequence","title":"getBytes"},{"location":"crypto/#checktransaction","text":"checkTransaction(tx, secondPublicKey=None, multiPublicKeys=[]) Verify transaction validity. Arguments : tx (dict or Transaction): transaction object secondPublicKey (str): second public key to use if needed multiPublicKeys (list): owners public keys (sorted according to associated type-4-tx asset) Returns : True if transaction is valid","title":"checkTransaction"},{"location":"crypto/#dposlibarkldgr","text":"This module contains functions to interoperate with Ledger hard wallet.","title":"dposlib.ark.ldgr"},{"location":"crypto/#parsebip44path","text":"parseBip44Path(path) Parse a BIP44 derivation path. Arguments : path str - the derivation path Returns : parsed bip44 path as bytes","title":"parseBip44Path"},{"location":"crypto/#buildpukapdu","text":"buildPukApdu(dongle_path) Generate apdu to get public key from ledger key. Arguments : dongle_path bytes - value returned by dposlib.ark.ldgr.parseBip44Path Returns : public key apdu data as bytes","title":"buildPukApdu"},{"location":"crypto/#getpublickey","text":"getPublicKey(path=None, debug=False) Compute the public key associated to a derivation path. Arguments : path str - derivation path debug bool - flag to activate debug messages from ledger key Returns : hexadecimal compressed publicKey","title":"getPublicKey"},{"location":"crypto/#signmessage","text":"signMessage(msg, path=None, schnorr=True, debug=False) Compute schnorr or ecdsa signature of msg according to derivation path. Arguments : msg str or bytes - transaction as dictionary path str - derivation path schnorr bool - use schnorr signature if True else ecdsa debug bool - flag to activate debug messages from ledger key","title":"signMessage"},{"location":"crypto/#signtransaction","text":"signTransaction(tx, path=None, schnorr=True, debug=False) Append sender public key and signature into transaction according to derivation path. Arguments : tx dposlib.blockchain.tx.Transaction - transaction path str - derivation path schnorr bool - use schnorr signature if True else ecdsa debug bool - flag to activate debug messages from ledger key","title":"signTransaction"},{"location":"network/","text":"dposlib.rest # rest module provides network loaders and usrv.get.EndPoint root class to implement GET , POST , PUT and DELETE HTTP requests. See Ark API documentation to see how to use http calls. rest also creates a core module containing dposlib.blockchain.tx.Transaction builders, dposlib.ark.crypto and dposlib.ark.v2.api interface. rest HTTP request builder # >>> from dposlib import rest >>> rest.use(\"ark\") True >>> # reach http://api.ark.io/api/delegates/arky endpoint using GET >>> # HTTP request builder >>> rest.GET.api.delegates.arky()[\"username\"] 'arky' core module # >>> import dposlib >>> dlgt = dposlib.core.api.Delegate(\"arky\") >>> dlgt.forged {u'rewards': 397594.0, u'total': 401908.71166083, u'fees': 4314.71166083} >>> dposlib.core.crypto.getKeys(\"secret\")[\"publicKey\"] '03a02b9d5fdd1307c2ee4652ba54d492d1fd11a7d1bb3f3a44c4a05e79f19de933' >>> dposlib.core.transfer( ... 1, \"ARfDVWZ7Zwkox3ZXtMQQY1HYSANMB88vWE\", ... u\"\\u2728 simple transfer vendorField\" ... ) { \"amount\": 100000000, \"asset\": {}, \"recipientId\": \"ARfDVWZ7Zwkox3ZXtMQQY1HYSANMB88vWE\", \"type\": 0, \"vendorField\": \"\\u2728 simple transfer vendorField\", \"version\": 1 } >>> dposlib.core.htlcLock( ... 1, \"ARfDVWZ7Zwkox3ZXtMQQY1HYSANMB88vWE\", ... \"my secret lock\", expiration=12, ... vendorField=u\"\\u2728 simple htlcLock vendorField\" ... ) { \"amount\": 100000000, \"asset\": { \"lock\": { \"secretHash\": \"dbaed2f2747c7aa5a834b082ccb2b648648758a98d1a415b2ed9a22fd29d47cb\", \"expiration\": { \"type\": 1, \"value\": 82567745 } } }, \"network\": 23, \"recipientId\": \"ARfDVWZ7Zwkox3ZXtMQQY1HYSANMB88vWE\", \"type\": 8, \"typeGroup\": 1, \"vendorField\": \"\\u2728 simple htlcLock vendorField\", \"version\": 2 } GET # GET HTTP request builder POST # POST HTTP request builder PUT # PUT HTTP request builder DELETE # DELETE HTTP request builder load # load(name) Load a given blockchain package as dposlib.core module. A valid blockchain package must provide init(peer=None) and stop() definitions. Available blockchains are referenced in dposli.net module. Arguments : name str - package name to load use # use(network, **kwargs) Sets the blockchain parameters in the dposlib.rest.cfg module and initializes blockchain package. Network options can be created or overriden using **kwargs argument. Arguments : network str - network to initialize Returns : True if network connection established","title":"Network"},{"location":"network/#dposlibrest","text":"rest module provides network loaders and usrv.get.EndPoint root class to implement GET , POST , PUT and DELETE HTTP requests. See Ark API documentation to see how to use http calls. rest also creates a core module containing dposlib.blockchain.tx.Transaction builders, dposlib.ark.crypto and dposlib.ark.v2.api interface.","title":"dposlib.rest"},{"location":"network/#rest-http-request-builder","text":">>> from dposlib import rest >>> rest.use(\"ark\") True >>> # reach http://api.ark.io/api/delegates/arky endpoint using GET >>> # HTTP request builder >>> rest.GET.api.delegates.arky()[\"username\"] 'arky'","title":"rest HTTP request builder"},{"location":"network/#core-module","text":">>> import dposlib >>> dlgt = dposlib.core.api.Delegate(\"arky\") >>> dlgt.forged {u'rewards': 397594.0, u'total': 401908.71166083, u'fees': 4314.71166083} >>> dposlib.core.crypto.getKeys(\"secret\")[\"publicKey\"] '03a02b9d5fdd1307c2ee4652ba54d492d1fd11a7d1bb3f3a44c4a05e79f19de933' >>> dposlib.core.transfer( ... 1, \"ARfDVWZ7Zwkox3ZXtMQQY1HYSANMB88vWE\", ... u\"\\u2728 simple transfer vendorField\" ... ) { \"amount\": 100000000, \"asset\": {}, \"recipientId\": \"ARfDVWZ7Zwkox3ZXtMQQY1HYSANMB88vWE\", \"type\": 0, \"vendorField\": \"\\u2728 simple transfer vendorField\", \"version\": 1 } >>> dposlib.core.htlcLock( ... 1, \"ARfDVWZ7Zwkox3ZXtMQQY1HYSANMB88vWE\", ... \"my secret lock\", expiration=12, ... vendorField=u\"\\u2728 simple htlcLock vendorField\" ... ) { \"amount\": 100000000, \"asset\": { \"lock\": { \"secretHash\": \"dbaed2f2747c7aa5a834b082ccb2b648648758a98d1a415b2ed9a22fd29d47cb\", \"expiration\": { \"type\": 1, \"value\": 82567745 } } }, \"network\": 23, \"recipientId\": \"ARfDVWZ7Zwkox3ZXtMQQY1HYSANMB88vWE\", \"type\": 8, \"typeGroup\": 1, \"vendorField\": \"\\u2728 simple htlcLock vendorField\", \"version\": 2 }","title":"core module"},{"location":"network/#get","text":"GET HTTP request builder","title":"GET"},{"location":"network/#post","text":"POST HTTP request builder","title":"POST"},{"location":"network/#put","text":"PUT HTTP request builder","title":"PUT"},{"location":"network/#delete","text":"DELETE HTTP request builder","title":"DELETE"},{"location":"network/#load","text":"load(name) Load a given blockchain package as dposlib.core module. A valid blockchain package must provide init(peer=None) and stop() definitions. Available blockchains are referenced in dposli.net module. Arguments : name str - package name to load","title":"load"},{"location":"network/#use","text":"use(network, **kwargs) Sets the blockchain parameters in the dposlib.rest.cfg module and initializes blockchain package. Network options can be created or overriden using **kwargs argument. Arguments : network str - network to initialize Returns : True if network connection established","title":"use"}]}